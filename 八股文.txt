***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
一、8种基本数据类型
		1000 1110共有八个位，它的英文名字叫（bit），是计算机中最基本的单位。
		Byte，是由八个位组成的一个单元,A便用 “0100 0001”来表示,8位一个字节
		

	4大类
	1) 逻辑类型: 
		boolean(8位, 1字节)
		1)) 布尔类型占1个字节（8位），它的的值，必须是true或者false。
		2)) 在JVM中会转换为1（true）或者0（false）。
	2) 整型: 
	byte(8位, 1字节)
	short(16位, 2字节)
	int(32位, 4字节)
	long(64位, 8字节)
	3) 浮点型:
	float
	1)) 内存中占32位, 1符号位+8指数位+23尾数。
	2)) float的精度为7位左右有效数字。
	3)) float浮点型数据的声明：后面加f或者F。
	double
	1)) 内存中占64位 1符号位+11指数位+52尾数位。
	2)) double的精度为16位左右有效数字。
	3)) double浮点型数据的声明：后面加d或者D。
	4) 字符型:
	char
	1)) char类型占2个字节（16位），用来表示字符。
	2)) char是基本数据类型。String表示字符串，是类类型。一个String是由0~n个char组成。
	3)) 字符使用单引号表示，字符串使用双引号表示
	
	int范围: -128~127 (-0 = 128)
	Integer范围: -2^31~2^31-1
***********************************************************************************************	
***********************************************************************************************
	数据类型	      默认值	      大小
	boolean	      false	          1 比特/1位
	char	      '\u0000'	      2 字节
	byte	            0	              1 字节
	short	            0	              2 字节
	int	                0	              4 字节
	long	            0L	          8 字节
	float	            0.0f	          4 字节
	double	        0.0	          8 字节
	
	1 Byte/字节 = 8 Bit/位/比特
	1 KB             =   1024 Byte
	1 MB            =   1024 KB
	1 GB            =    1024 M
	1 TB             =    1024 GB
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
二、常见的数据结构

		1) 数组(Arrary)
			连续的内存空间存储同类型的数据。
			优点：查询效率高，随机访问性强。
			缺点：大小固定，不易动态扩展，插入和删除数据效率低。
		2) 链表(Linked List)
			节点之间通过指针或引用相连，形成链式结构。
			优点：内存占用宽松，扩展灵活，不需要连续的内存空间。
			缺点：查询效率低，需要从头节点开始遍历。
		3) 栈(Stack)
			遵循后进先出（LIFO）原则的数据结构。
			通常用于实现方法调用、表达式求值等。
		4) 队列(Queue)
			遵循先进先出（FIFO）原则的数据结构。
			常用于实现缓冲区、任务调度等。
		5) 树(Tree)
			一种非线性的数据结构，具有层次关系。
			常见类型有：二叉树、红黑树、AVL树、B树、B+树等。
			广泛用于数据库索引、文件系统、搜索引擎等。
		6) 图(Graph)
			由顶点和边组成的数据结构，表示对象之间的多对多关系。
			常用于表示网络、社交关系等。
		7) 哈希表(Hash Table)
			通过哈希函数将键映射到存储位置的数据结构。
			优点：查询、插入和删除操作的平均时间复杂度为O(1)。
			Java中的HashMap就是哈希表的一种实现。
		8) 堆(Heap)
			一种特殊的树形数据结构，用于实现优先队列。
			最大堆：父节点值大于等于子节点值，常用于实现最大数据项的快速读取。
			最小堆：父节点值小于等于子节点值，常用于实现最小数据项的快速读取。
			
----------------二叉树
叶子节点: 没有子结点（即度为0）的结点
		   度: 结点拥有的子树数目称为结点的度
		    1. 二叉树
				二叉树是每个节点最多有两个子树的树结构
			2. 完全二叉树：
				除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点
			3. 满二叉树
				除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树
			4. 二叉搜索树/二叉排序树/二叉查找树
				若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树
				二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。
				中序遍历: 二叉搜索树中序遍历得到的值序列是递增有序的
				***特殊情况：每个节点只有右节点
										这种情况下，二叉搜索树已经变更为链表，搜索一个元素的时间复杂度从O(lgn)退化为O(n)出现这种情况的原因是二叉搜索树没有自平衡的机制，所以就有了平衡二叉树
			5. 平衡二叉树
				平衡二叉树是一种概念，是二叉查找树的一个进化体，它有几种实现方式：红黑树、AVL树
					它是一个空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。
					这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多
				AVL实现平衡的关键在于旋转操作：
					插入和删除可能破坏二叉树的平衡，此时需要通过一次或多次树旋转来重新平衡这个树。当插入数据时，最多只需要1次旋转(单旋转或双旋转)；但是当删除数据时，会导致树失衡，AVL需要维护从被删除节点到根节点这条路径上所有节点的平衡，旋转的量级为O(lgn)
					由于旋转的耗时，AVL树在删除数据时效率很低；在删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛
			6. 红黑树
				红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于1，所以红黑树不是严格意义上的平衡二叉树（AVL），但对之进行平衡的代价较低， 其平均统计性能要强于 AVL
				红黑树的特性:
					1. 每个节点或者是黑色，或者是红色
					2. 根节点是黑色
					3. 每个叶结点是黑色
					4. 如果一个节点是红色的，则它的子节点必须是黑色的，红色节点的孩子和父亲都不能是红色。
					从每个叶子到根的所有路径上不能有两个连续的红色节点，任意一结点到每个叶子结点的路径都包含数量相同的黑结点。
					确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对接近平衡的二叉树，并不是一个完美平衡二叉查找树
		**************************
					红黑树和AVL树区别:
					RB-Tree和AVL树作为二叉搜索树(BBST)，其实现的算法时间复杂度相同，
					AVL作为最先提出的BBST，貌似RB-tree实现的功能都可以用AVL树是代替，那么为什么还需要引入RB-Tree呢
						AVL更平衡，结构上更加直观，时间效能针对读取而言更高；维护稍慢，空间开销较大。
						红黑树，读取略逊于AVL，维护强于AVL，空间开销与AVL类似，内容极多时略优于AVL，维护优于AVL。
			7. B树类型
				1) B-树
							一种平衡的多叉树，称为B树（或B-树、B_树，B：balanced说明B树和平衡树有关系）
							B树是为磁盘等辅存设备设计的多路平衡查找树，与二叉树相比，B树的每个非叶节点可以有多个子树。 因此，当总节点数量相同时，B树的高度远远小于AVL树和红黑树(B树是一颗“矮胖子”)，磁盘IO次数大大减少
				2) B+树
							B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。
				3) B*树
							B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
三、Java的集合框架/Java集合框架是基本数据结构在Java语言中的实现和描述。
Java集合框架和基本数据结构之间有着密切的关系。简单来说，Java集合框架是基本数据结构在Java语言中的实现和描述。

基本数据结构，如数组、链表、栈、队列、树和图等，是计算机科学中用于组织和存储数据的基本方式。每种数据结构都有其特定的特性和适用场景。
例如，数组适合用于存储连续且类型相同的数据，而链表则适合用于动态地添加和删除元素。

Java集合框架将这些基本数据结构进行了封装和抽象，提供了统一的接口和实现类。这使得开发者可以更加便捷地使用这些数据结构，而无需关心底层的实现细节。
Java集合框架中的接口定义了操作集合的通用方法，如添加、删除、查找等，而实现类则提供了这些方法的具体实现。

Java集合框架中的实现类通常都是基于基本数据结构进行实现的。例如，ArrayList和LinkedList就是基于数组和链表这两种基本数据结构实现的List接口。
HashSet和TreeSet则是基于哈希表和红黑树这两种基本数据结构实现的Set接口。

因此，可以说Java集合框架和基本数据结构是相互依存的。基本数据结构为Java集合框架提供了底层支持，而Java集合框架则为开发者提供了使用这些基本数据结构的便捷方式。

Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；
Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQueue。
Map，代表键值对的集合，典型代表就是 HashMap。
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
****1. Collection
				List: 初始容量10, 扩容因子1.5(添加第 10 个元素时，容量会增加到 15（即 10 * 1.5）)
				Map: 默认的初始容量是 16，负载因子是 0.75。容量翻倍, 扩容后，所有的键值对都会重新进行哈希计算
		1) Set/接口/继承Collection接口
		Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。
			1)) EnumSet
			EnumSet 是 Java 中的一个特殊集合，用于存储枚举类型的元素
			2)) SortedSet/接口/继承自Set
				@@@1))) TreeSet/类/SortedSet实现类
				
				TreeSet 是由 TreeMap（后面会讲） 实现的
				与 TreeMap 相似，TreeSet 是一种基于红黑树实现的有序集合，它实现了 SortedSet 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。
				TreeSet 不允许插入 null 元素，否则会抛出 NullPointerException 异常。(因为要比较大小排序, null无法与任何值比较)
				
			@@@3)) HashSet/类/Set实现类
			HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作
			实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；
			如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。
			HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。
			允许插入一个 null 
			
			@@@4)) LinkedHashSet/类/Set实现类/继承自HashSet
			LinkedHashSet 虽然继承自 HashSet，其实是由 LinkedHashMap 实现的。
			LinkedHashSet 是一种基于哈希表实现的 Set 接口，它继承自 HashSet，并且使用链表维护了元素的插入顺序。
			因此，它既具有 HashSet 的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。
			允许插入一个 null
			
		2) Queue/接口/继承自Collection接口
		
		LinkedList, ArrayDeque, 实现了Queue的子接口Deque
		PriorityQueue, 单向队列, 3个都实现了Queue接口
		
		队列(Queue)：队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。
		符合先进先出(First In First Out/FIFO)的设计原则
		
		@@@LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。
				1)) offer: 添加元素到队尾, 返回值: boolean
				2)) poll: 获取队首元素并删除, 返回值: 队首元素
				3)) peek: 获取队首元素
				add()和remove()方法在失败的时候会抛出异常(不推荐)
				Queue是一个队列规范的接口，Deque是一个双端队列实现的接口，由于两个都是接口，所以是不能直接进行是实例化的，需要接口引用具体的类来进行实例化，
				所以底层可以是顺序表（数组），也可以是链表（单 / 双链表）。
				
			@@@1)) Deque/queue的子接口
				1)))ArrayDeque/Deque实现类
				当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列）
				基于数组实现的线性双向队列，通常作为栈或队列使用，
				ArrayDeque用作栈时比Stack快没有疑问，用作队列的时候似乎也会比LinkedList快
				当你插入的对象有可能会为null的情况，只能采用LinkedList来实现栈、队列的效果
				
				ArrayDeque是 Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。同时， ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。
				ArrayDeque是 Deque的实现类，可以作为栈来使用，效率高于 Stack；也可以作为队列来使用，效率高于 LinkedList。
				ArrayDeque 是 Java 集合中双端队列的数组实现，双端队列的链表实现（LinkedList）
				需要注意的是， ArrayDeque不支持 null值。
			@@@2)) PriorityQueue/优先级队列
				PriorityQueue 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。
			
		3) List/接口/继承Collection接口
		ArrayList, LinkedList, Vector
			@@@1)) LinkedList/List实现类
			LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。
			基于 链表 实现的链式双向队列，通常作为栈或队列使用，但是队列的效率不如ArrayQueue高
			ArrayDeque用作栈时比Stack快没有疑问，用作队列的时候似乎也会比LinkedList快
			当你插入的对象有可能会为null的情况，只能采用LinkedList来实现栈、队列的效果
			
			特点
			1.插入、删除、获取操作支持两种形式：快速失败和返回null或true/false
			2.既具有FIFO特点又具有LIFO特点，即是队列又是栈
			3.不推荐插入null元素，null作为特定返回值表示队列为空
			4.未定义基于元素相等的equals和hashCode
			@@@2)) ArrayList/List实现类
			**初始容量10, 扩容因子1.5(添加第 10 个元素时，容量会增加到 15（即 10 * 1.5）)
			ArrayList 是由 数组 实现的，支持随机存取，也就是可以通过下标直接存取元素；
			从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；
			如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。
			3)) Vector
			初始容量10, 扩容因子翻倍
				add, remove, get
				线程安全
		
****2. Map
		1) EnumMap
		2) IdentityHashMap
		3) HashMap
		map.computeIfAbsent(key, k->"").subString(), map.getOrDefault()
		HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。
		可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。
		默认的初始容量是 16，负载因子是 0.75。容量翻倍, 扩容后，所有的键值对都会重新进行哈希计算
		HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，
		也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。
		HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值，算法时间复杂度可以达到 O(1)。

		当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。
			1)) LinkedHashMap
		4) HashTable
		Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。
			1)) Properties
			Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。 Properties被称为属性类对象。 Properties是线程安全的。
		5) WeakHashMap
		6) SortedMap
			1) TreeMap
			
***Comparable 和 Comparator 两者之间的区别：*******************************************

	Comparable用法：对需要排序的类，实现Comparable接口，重写compareTo()方法。
	Comparator用法：创建自定义比较器，实现Comparator接口，重写compare()方法。还可以通过匿名类的方式更快速便捷的完成自定义比较器的功能。

一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。
一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。
Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。

Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。

Collection与Collections的区别
Collection是集合类的上级接口，继承与他有关的接口主要有List和Set
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作
***compute, computeIfAbsent, computeIfPresent*******************************************
	compute: 有则覆盖，没则添加
	computeIfAbsent: 有则不操作，没则添加
	computeIfPresent: 有则覆盖，没值的时候不操作
	相同：返回值是返回最新的值
	Absent: 缺席
	
	Map.getOrDefault
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------				
****3. Stack
		1) Java 里有一个叫做Stack的类，却没有叫做Queue的类（它只是个接口名字，和类还不一样）。
		当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列），
		原因我们第一次讲集合框架的时候，其实已经聊过了，Stack 是一个“原始”类，
		它的核心方法上都加了 synchronized 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。
		
		遵循后进先出原则的数据结构(Last In First Out/LIFO)/线性数据结构
		
		Java 已经帮我们实现了一个栈，就是 java.util.Stack，它继承自 Vector，是线程安全的，有点 StringBuffer 的感觉，笨笨的。
		
		1))  Stack是Vector的一个子类，它实现标准的后进先出堆栈。
		栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。
		
		主要有5个
		
			1))) push: 将项压入栈顶
			2))) pop: 移除栈顶对象，并作为此函数的值返回该对象。
			3))) peek: 查看栈顶对象而不移除它。
			4))) search: 返回对象在堆栈中的位置，以 1 为基数。(从顶向下数，从1开始计数)找不到返回-1
			5))) empty: 判断栈是否为空, 返回值为 boolean类型
		
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
&&&&4. Java的并发容器
					Java 的并发集合容器提供了在多线程环境中高效访问和操作的数据结构。这些容器通过内部的同步机制实现了线程安全，
					使得开发者无需显式同步代码就能在并发环境下安全使用，比如说：ConcurrentHashMap、阻塞队列(BlockingQueue: ArrayBlockingQueue)
					和 CopyOnWrite 容器等。

					java.util 包下提供了一些容器类（集合框架），其中 Vector 和 Hashtable 是线程安全的，但实现方式比较粗暴，通过在方法上加「sychronized」关键字实现。

					但即便是 Vector 这样线程安全的类，在应对多线程的复合操作时也需要在客户端继续加锁以保证原子性。
					
					1) Queue
						1)) BlockingQueue/阻塞队列
							1))) ArrayBlockingQueue
							2))) PriorityBlockingQueue
							3))) SynchronousQueue
							4))) DelayQueue
							5))) LinkedBlockingQueue
							
							6))) BlockingQueue
							7))) LinkedBlockingQueue
							
							8))) TransferQueue
							9))) LinkedTransferQueue
					2) ConcurrentMap
						1)) ConcurrentHashMap ***
						2)) ConcurrentNavigableMap
						3)) ConcurrentSkipListMap
							
					3) CopyOnWrite
						1)) CopyOnWriteArraySet
						2)) CopyOnWriteArrayList ***
						3)) ConcurrentLinkedDeque
						4)) ConcurrentLinkedQueue
						5)) ConcurrentSkipListMap
					4) List
						手动加锁
						Collections.synchronizedList()
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------		
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
四、Java IO		
			字节流可以处理一切文件，而字符流只能处理文本。
			虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。
			虽然 IO 类的方法也很多，但核心的也就 2 个：read 和 write。
			
			字节流和字符流的区别：

			字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，
			但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。
			字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。
			而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。
			按照 IO 的操作对象来思考，IO 就可以分类为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换等。
*********1. 字节流
					1. 字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。

*********2. 字符流
					1. 字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。
					
		1）文件
文件流也就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWriter）。
		2）数组（内存）
通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。
		3）管道
Java 中的管道和 Unix/Linux 中的管道不同，在 Unix/Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，
通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。
一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。

使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。
但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。
		4）基本数据类型
基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。
DataInputStream 提供了一系列可以读基本数据类型的方法
DataOutputStream 提供了一系列可以写基本数据类型的方法
除了 DataInputStream 和 DataOutputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，
包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）
		5）缓冲
CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。

为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。
		6）打印
Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。

恐怕 Java 程序员一生当中最常用的就是打印流了：System.out 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。
		7）对象序列化/反序列化
序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。
		8）转换
InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将它们解码为字符。
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
五、异常处理
***********************************************************************************************
***********************************************************************************************
1. Exception和Error的区别
从单词的释义上来看，error 为错误，exception 为异常，错误的等级明显比异常要高一些。

从程序的角度来看，也的确如此。

Error 的出现，意味着程序出现了严重的问题，而这些问题不应该再交给 Java 的异常处理机制来处理，
程序应该直接崩溃掉，比如说 OutOfMemoryError，内存溢出了，这就意味着程序在运行时申请的内存大于系统能够提供的内存，导致出现的错误，这种错误的出现，对于程序来说是致命的。

Exception 的出现，意味着程序出现了一些在可控范围内的问题，我们应当采取措施进行挽救。

比如说之前提到的 ArithmeticException，很明显是因为除数出现了 0 的情况，我们可以选择捕获异常，
然后提示用户不应该进行除 0 操作，当然了，更好的做法是直接对除数进行判断，如果是 0 就不进行除法运算，而是告诉用户换一个非 0 的数进行运算。

2. checked和unchecked异常
checked 异常（检查型异常）在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作；
而 unchecked 异常（非检查型异常）就是所谓的运行时异常，通常是可以通过编码进行规避的，并不需要显式地捕获或者抛出。
@@@Throwable
	1) Exception
		1)) CheckedException
			 IOException
			 SQLException
			 ClassNotFoundException
		2)) UncheckedException
			 NullPointerException
			 ArrayIndexOutOfBoundsException
			 IllegalArgumentException
	2) Error
		OutOfMemoryError
		StackOverflowError
		NoClassDefFoundError
首先，Exception 和 Error 都继承了 Throwable 类。换句话说，只有 Throwable 类（或者子类）的对象才能使用 throw 关键字抛出，或者作为 catch 的参数类型。

面试中经常问到的一个问题是，NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
        它们都是由于系统运行时找不到要加载的类导致的，但是触发的原因不一样。
		NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是 jar 包缺失或者调用了初始化失败的类。
		ClassNotFoundException：当动态加载 Class 对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了。
3. 关于throw和throws
		throw: “throw 关键字，用于主动地抛出异常；正常情况下，当除数为 0 的时候，程序会主动抛出 ArithmeticException；
		但如果我们想要除数为 1 的时候也抛出 ArithmeticException，就可以使用 throw 关键字主动地抛出异常。
		throws 关键字的作用就和 throw 完全不同
		对于检查型异常来说，如果你没有做处理，编译器就会提示你
		1）throws 关键字用于声明异常，它的作用和 try-catch 相似；而 throw 关键字用于显式的抛出异常。

		2）throws 关键字后面跟的是异常的名字；而 throw 关键字后面跟的是异常的对象。
		
finally不执行的情况
	遇到了死循环。
	执行了 System. exit() 这行代码。
System.exit() 和 return 语句不同，前者是用来退出程序的，后者只是回到了上一级方法调用

4. try-catch-resource
try-with-resources语句是一种声明了一种或多种资源的try语句。资源是指在程序用完了之后必须要关闭的对象。
try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。任何实现了java.lang.AutoCloseable接口的对象，和实现了java.io.Closeable接口的对象，都可以当做资源使用。

如果一个类实现了 AutoCloseable 接口，并行重写 close 方法。那么这个类就可以写在try-catch的try后面的括号中，并且能在try-catch块执行后自动执行这个方法。

建议使用try-with-resources替代try-cache-finall，使代码更简洁，开发更容易。

***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
六、常用工具类
1. Scanner
2. Arrays
3. StringUtils
4. Objects
5. Collections
6. Hutool
7. Guava
8. 其他IPUtil、CollectionUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
七、Java新特性(流Stream/Optional/Lambda)
		1. 掌握Stream流
			Java Stream流是Java 8 API添加的一个新的抽象，用于处理数据集合。Stream是一个来自数据源的元素队列，元素是特定类型的对象，形成一个队列。
			这个数据源可以是集合、数组等，而Stream并不会存储元素，而是按需计算。
			Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。它的主要目的在于计算，而不是存储数据。
			通过Stream，程序员可以以一种声明性的方式处理数据集合，这侧重于对源数据计算能力的封装，并支持序列与并行两种操作方式。
			Stream是对集合（Collection）对象功能的增强，与Lambda表达式结合，可以提高编程效率、间接性和程序可读性。它让程序员能够写出高效率、干净、简洁的代码。
			Stream的使用步骤通常包括：得到集合/数组Stream流对象，创建Stream对象，然后调用Stream类相关API进行数据加工处理。
			Stream流的三类方法主要包括：获取Stream流、创建一条流水线并把数据放到流水线上准备进行操作，以及流水线上的中间方法操作。

		总结来说，Java Stream流是一个强大的工具，它提供了一种灵活且高效的方式来处理数据集合，使得Java程序员能够更简洁、更直观地表达复杂的集合操作。
		要想操作流，首先需要有一个数据源，可以是数组或者集合。每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。

		流的操作可以分为两种类型：

		1）中间操作，可以有多个，每次返回一个新的流，可进行链式操作。

		2）终端操作，只能有一个，每次执行完，这个流也就用光光了，无法执行下一个操作，因此只能放在最后。
		如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流；如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。
		1）过滤
		通过 filter() 方法可以从流中筛选出我们想要的元素。
		2）映射
		如果想通过某种操作把一个流中的元素转化成新的流中的元素，可以使用 map() 方法。
		3）匹配
		Stream 类提供了三个方法可供进行元素匹配
		4）组合
		reduce() 方法的主要作用是把 Stream 中的元素组合起来
		03、转换流
		既然可以把集合或者数组转成流，那么也应该有对应的方法，将流转换回去——collect() 方法就满足了这种需求。
		2. Optional
		Optional<String> empty = Optional.empty();
		ifPresent()
		Optional.ofNullable(null) (StringBuilder sb, sb.setLength(0))
		Predicate 是 Java 8 中引入的一个函数式接口，它属于 java.util.function 包。Predicate 接口代表了一个谓词，
		即一个返回布尔值的函数。它通常用于测试或过滤元素，例如在集合的 stream() 操作中。

		Predicate<Integer> isEven = num -> num % 2 == 0; 
		3. Java 8 Lambda表达式
		Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。
		( parameter-list ) -> { expression-or-statements }

		:: 双冒号运算操作符是类方法的句柄，lambda表达式的一种简写，这种简写的学名叫eta-conversion或者叫η-conversion。
		 forEach(System.out::print)
		 4. 
		 Java函数式编程是Java 8引入的一种新的编程范式。它强调将计算视为函数的运算，避免变化状态和可变数据。在函数式编程中，编程是用表达式或者声明而不是语句来完成的，这使得代码更加简洁且编写效率更高。

		Java函数式编程依赖于Streams和lambda表达式，这两者也都是Java 8中引入的。lambda表达式允许以简洁的方式表示匿名函数，而Streams则提供了一种在集合元素上执行复杂查询操作的高效方式。

		总的来说，Java函数式编程为开发者提供了一种新的、更简洁且高效的编程方式，特别适用于处理集合数据和执行复杂的查询操作。
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
八、网络编程
Socket
DatagramSocket 类是 Java 中实现 UDP 协议的核心类。与基于 TCP 的 Socket 和 ServerSocket 类不同，
DatagramSocket 类提供了无连接的通信服务，发送和接收数据包。由于无需建立连接，UDP 通常比 TCP 更快，但可能不如 TCP 可靠。
***********************************************************************************************
***********************************************************************************************
九、Java NIO
传统 IO 基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，以及使用 Socket 和 ServerSocket 进行网络传输。
NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，以及使用 SocketChannel 和 ServerSocketChannel 进行网络传输。
传统 IO 采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待 I/O 操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。

NIO 使用非阻塞模型，允许线程在等待 I/O 时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道（Channel）上的 I/O 事件，实现了更高的性能和可伸缩性。

BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。
NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。
AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。
***********************************************************************************************
***********************************************************************************************
十、Java重要知识点
1. Java命名规范
		1) 包
			1. 应该全部是小写字母
			2. 点分隔符之间有且仅有一个自然语义的英语单词
			3. 包名统一使用单数形式***，比如说 com.itwanger.util 不能是 com.itwanger.utils 
			4. 在最新的 Java 编程规范中，要求开发人员在自己定义的包名前加上唯一的前缀。
				由于互联网上的域名是不会重复的，所以多数开发人员采用自己公司（或者个人博客）在互联网上的域名称作为包的唯一前缀。
				比如我文章中出现的代码示例的包名就是 package com.itwanger。
		2) 类		
		类方法：类中用 static 修饰的方法。
		实例方法：也称为对象方法，除了类方法都是实例方法。
			类的命名应该遵守以下规则：
			1. 必须以大写字母开头
			2. 最好是一个名词，比如说 System
			3. 类名使用 UpperCamelCase（驼峰式命名）风格
			4. 尽量不要省略成单词的首字母，但以下情形例外：DO/BO/DTO/VO/AO/PO/UID 等
		另外，如果是抽象类的话，使用 Abstract 或 Base 开头；如果是异常类的话，使用 Exception 结尾；如果是测试类的话，使用 Test 结尾。
		3) 接口
			接口的命名应该遵守以下规则：
			1. 必须以大写字母开头
			2. 最好是一个形容词，比如说 Runnable
			3. 尽量不要省略成单词的首字母		
		接口和实现类之间也有一些规则：
		实现类用 Impl 的后缀与接口区别，比如说 CacheServiceImpl 实现 CacheService 接口
		或者，AbstractTranslator 实现 Translatable 接口		
		4) 字段（field）和变量（variable）
			字段和变量的命名应该遵守以下规则：
			1. 必须以小写字母开头
			2. 可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 firstName
			3. 最好不要使用单个字符，比如说 int a，除非是局部变量
			4. 类型与中括号紧挨相连来表示数组，比如说 int[] arrayDemo，main 方法中字符串数组参数不应该写成 String args[]
			5. POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误，我自己知道的有 fastjson
			6. 避免在子类和父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可理解性降低。子类、父类成员变量名相同，即使是 public 类型的变量也能够通过编译，另外，局部变量在同一方法内的不同代码块中同名也是合法的，这些情况都要避免。
		5) 常量 (constant)
			常量的命名应该遵守以下规则：
			1. 应该全部是大写字母
			2. 可以包含多个单词，单词之间使用“_”连接，比如说 MAX_PRIORITY，力求语义表达完整清楚，不要嫌名字长
			3. 可以包含数字，但不能以数字开头
		6) 方法
			方法的命名应该遵守以下规则：
			1. 必须以小写字母开头
			2. 最好是一个动词，比如说 print()
			3. 可以包含多个单词，第一个单词的首字母小写，其他的单词首字母大写，比如说 actionPerformed()
			总结一下：
		除了以上这些规则以外，还有一些共同的规则需要遵守，比如说：
		1. 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例：_name / __name / $name / name_ / name$ / name__
		2. 所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。反例：DaZhePromotion [打折] / getPingfenByName() [评分] / String fw[福娃] / int 某变量 = 3
		3. 代码和注释中都要避免使用任何语言的种族歧视性词语。反例：RIBENGUIZI / Asan / blackList / whiteList / slave
			方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。
		3. 杜绝完全不规范的缩写，避免望文不知义。反例：AbstractClass “缩写”成 AbsClass；condition “缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。
		4. 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。
		5. 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT
		6. 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。比如说：public class OrderFactory;public class LoginProxy;public class ResourceObserver;
		7. 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的常量类，且构造方法被默认强制是私有。比如说：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。
2. 中文乱码及字符编码全攻略
	1) ACSII: 128个,  其中33 个字符无法显示在一般的设备上，需要用特殊的设备才能显示。
	2) Unicode 是一个很大的集合，现在的规模可以容纳 100 多万个符号
	3) UTF-8, 存储优化
	4) GB2312, 对于中文的优化, GBK(扩展), GB/国标
	5) 编码转换问题导致乱码, 锟斤拷，第一时间想到 UTF-8 和 GBK 的转换问题准没错
	6) 以下是一些避免乱码的实践：
			1. 使用统一的字符编码，如 UTF-8。它包含了所有 Unicode 字符，并且广泛支持。确保在所有平台和系统上使用相同的编码。
			2. 在处理文本文件时，始终明确指定字符编码。例如，在 Java 中使用 InputStreamReader、OutputStreamWriter 时，指定编码参数。
			3. 在 HTML、XML 等文档中，指定字符编码。例如，在 HTML 页面中添加 <meta charset="UTF-8">。
			4. 对于数据库，确保使用正确的字符集。在创建数据库和表时，明确指定字符集，如 utf8mb4。
3. 拆箱和装箱
	1) 泛型
		Java泛型（Generics）是JDK 5.0及以后版本引入的一个新特性
		主要特点包括：类型安全, 代码复用, 消除代码冗余
									泛型类型参数在运行时会被擦除
									泛型通配符<?>
									上限通配符<? extends T>
									下限通配符<? super T>
		应用场景: 类型参数化, 定义类时, 定义接口时, 定义方法时
	2) 拆箱就是将包装类型对象转换为其对应的基本数据类型，而装箱则是将基本数据类型转换为相应的包装类型对象。
	3) 包装类型可用于泛型，而基本数据类型不可以. 因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本数据类型是个例外。
	4) 很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。
		基本数据类型：仅占用足够存储其值的固定大小的内存。例如，一个 int 值占用 4 字节。
		包装类型：占用的内存空间要大得多，因为它们是对象，并且要存储对象的元数据。例如，一个 Integer 对象占用 16 字节。
	5) 通常来说，有 4 个地方可以用来存储数据。
		1. 寄存器: 这是最快的存储区，因为它位于 CPU 内部，用来暂时存放参与运算的数据和运算结果。
		2. 栈: 位于 RAM（Random Access Memory，也叫主存，与 CPU 直接交换数据的内部存储器）中，速度仅次于寄存器。
			但是，在分配内存的时候，存放在栈中的数据大小与生存周期必须在编译时是确定的，缺乏灵活性。基本数据类型的值和对象的引用通常存储在这块区域。
		3. 堆: 也位于 RAM 区，可以动态分配内存大小，编译器不必知道要从堆里分配多少存储空间，生存周期也不必事先告诉编译器，
			Java 的垃圾收集器会自动收走不再使用的数据，因此可以得到更大的灵活性。但是，运行时动态分配内存和销毁对象都需要占用时间，所以效率比栈低一些。new 创建的对象都会存储在这块区域。
		4. 磁盘: 如果数据完全存储在程序之外，就可以不受程序的限制，在程序没有运行时也可以存在。
			像文件、数据库，就是通过持久化的方式，让对象存放在磁盘上。当需要的时候，再反序列化成程序可以识别的对象。		
	6) 自动装箱是通过 Integer.valueOf() 完成的；自动拆箱是通过 Integer.intValue() 完成的。
		在Integer类中，hashCode方法返回的就是Integer的值本身。
		当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。
		自动装箱, 自动拆箱耗性能
4. 深入理解Java浅拷贝与深拷贝
		浅拷贝克隆的对象中，引用类型的字段指向的是同一个，当改变任何一个对象，另外一个对象也会随之改变，除去字符串的特殊性外
		通过 clone() 方法实现的深拷贝比较笨重，因为要将所有的引用类型都重写 clone() 方法，当嵌套的对象比较多的时候，就废了
		利用序列化: 序列化是将对象写到流中便于传输，而反序列化则是将对象从流中读取出来
		写入流中的对象就是对原始对象的拷贝。需要注意的是，每个要序列化的类都要实现 Serializable 接口，该接口和 Cloneable 接口类似，都是标记型接口。
			//深度拷贝
			public Object deepClone() throws IOException, ClassNotFoundException {
				// 序列化
				ByteArrayOutputStream bos = new ByteArrayOutputStream();
				ObjectOutputStream oos = new ObjectOutputStream(bos);

				oos.writeObject(this);

				// 反序列化
				ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
				ObjectInputStream ois = new ObjectInputStream(bis);

				return ois.readObject();
			}
对象
	1) 不管是浅拷贝还是深拷贝，都可以通过调用 Object 类的 clone() 方法来完成。
	2) clone() 方法同时是一个本地（native）方法
		clone()是一个空的接口
	3) 深拷贝需要重写 clone() 方法，并实现了 Cloneable 接口
		或者实现 Serializable 接口，该接口和 Cloneable 接口类似，都是标记型接口。
5. Java HashCode方法解析
	在 Java 中，hashCode()方法是定义在 java.lang.Object 类中的一个native方法，该类是所有 Java 所有类的父类。
	因此，每个 Java 对象都可以调用 hashCode()方法。hashCode()方法主要用于支持哈希表（如 java.util.HashMap），这些数据结构使用哈希算法能实现快速查找、插入和删除操作。
	hashCode()方法的主要目的是返回一个整数，这个整数称为哈希码，它代表了对象在内存中的一种近似表示。
	哈希码用于将对象映射到哈希表中的一个特定的位置。两个相等的对象（根据 equals()方法比较）应该具有相同的哈希码。然而，具有相同哈希码的两个对象并不一定相等。
	当你创建一个自定义类并覆盖 equals()方法时，通常也需要覆盖 hashCode()方法，以确保相等的对象具有相同的哈希码。这有助于提高哈希表在使用自定义类的对象作为键时的准确性。
			为什么重写equals()同时要重写hashcode
	如果两个String对象的内容相同（即equals()返回true），那么它们的hashCode()值也应该相同。
6. Java是值传递还是引用传递
	 Java 是按照值来传递的。
	 1. Java 中的参数传递是按值传递的。
	 2. 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。
	 3. 如果参数是引用类型，传递的是引用的对象在堆中地址的拷贝。
7. Java为什么无法实现真正的泛型
	1) 类型擦除: 也就是说, 编译后的字节码文件里，是没有泛型的，放的都是 Object。
	2) java版本发布历程
		1995年5月23日，Java语言诞生
		1996年1月，JDK1.0 诞生
		1997年2月18日，JDK1.1发布
		1998年2月，JDK1.1被下载超过2,000,000次
		2000年5月8日，JDK1.3发布
		2000年5月29日，JDK1.4发布
		2004年9月30日18:00 PM，J2SE1.5 发布
		J2SE1.5 的发布，是 Java 语言发展史上的重要里程碑，为了表示该版本的重要性，J2SE1.5 也正式更名为 Java SE 5.0，往后去就是 Java SE 6.0，Java SE 7.0。
		2006.11.13, JDK 6
		2009.2.19，JDK 7
		Oracle收购Sun
		2014.3.18 ,  JDK 8   
8. 掌握Java反射
		1) 反射的缺点主要有2个
			1. 破坏封装：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。
			2. 性能开销：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，
			所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。
		2) 反射的好处
			1. 提高程序的灵活性和扩展性: 动态创建, 控制类, 降低了模块的耦合性
			2. 方便获取类信息: 运行时得到变量,方法
				访问私有方法和字段时，我们需要调用 setAccessible(true) 方法来允许访问
				将值 设为true,压制(或者叫取消)java语言访问检查
			3. 提高代码复用率: 框架基础
		3) 应用场景
			1. 开发通用框架：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。
			2. 动态代理：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。
			3. 注解：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。
		4) 步骤
			geClass()->getConstructor()->getNewInstace()->getMethod()->invoke()
			获取Class对象->获取构造方法 Constructor 对象->初始化反射类对象->获取要调用的方法的 Method 对象->通过 invoke() 方法执行
				总结一下：
		反射是 Java 中的一个强大特性，它允许在运行时检查和操作类、接口、字段和方法。反射是 Java 的核心组件，支持各种框架和库的实现，
		如 Spring、Hibernate 等。使用反射，可以在运行时动态地创建对象、调用方法和访问字段，而无需在编译时了解这些对象的具体实现。
			反射的主要类位于 java.lang.reflect 包中，主要包括以下几个关键类：
		1. Class：代表一个类或接口，包含了类的结构信息（如名称、构造函数、方法、字段等）。通过 Class 对象，可以获取类的元数据并操作类的实例。
		2. Constructor：代表类的构造方法，用于创建类的实例。
		3. Method：代表类的方法，可以通过它调用类的实例方法。
		4. Field：代表类的字段，可以获取或修改字段的值。
		5. Modifier：包含方法、字段和类的访问修饰符（如 public、private 等）。
			使用反射时，需要注意以下几点：
		1. 性能：反射操作通常比直接操作对象的方法和字段慢，因为涉及到额外的间接调用和动态解析。因此，在关注性能的场景中，慎用反射。
		2. 安全性：通过反射，可以访问和操作类的私有字段和方法，这可能导致安全问题。因此，使用反射时要确保代码的安全性。
		3. 维护性：反射使代码变得更加复杂，可能导致难以维护。在使用反射时要确保代码的可读性和可维护性。
			尽管反射存在上述问题，但在某些场景下（如框架开发、动态代理等），它仍然是非常有用的工具。
***********************************************************************************************
***********************************************************************************************
十一、并发编程
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
业务需求、性能优化需要、可简化任务调度、并行程序在多核心CPU有优势。
****************************************************************************************************************
1. 创建线程的三种方式
1) 继承Thread类
Thread类本质上是实现了Runnable接口的一个实例，代表一个线程。通过Thread类的start()实例方法来启动线程。
start()方法是一个native方法（native方法：一个java调用而非java代码的接口），他会启动一个新线程，并执行run()方法。
创建一个类继承 Thread 类，并重写 run 方法。
定义Thread的子类，并重写run()方法，该方法的方法体就是线程需要完成的任务，run()方法也成为线程执行体

创建Thread子类的实例，也就是创建了线程对象
调用现成的start()方法，启动线程
2) 实现Runnble接口
创建一个类实现 Runnable 接口，并重写 run 方法。
实现Runnable接口创建线程步骤
定义Runnable实现类的实例，并重写run()方法，这个run()方法也是线程执行体

创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象
然后通过调用线程对象的start()方法来启动线程
3) 实现Callable接口
实现 Callable 接口，重写 call 方法，这种方式可以通过 FutureTask 获取任务执行的返回值。

*****而匿名内部类通常只用于创建一次性的线程对象。
	其它3种变形
		1.  匿名内部类创建 Thread 子类对象（匿名内部类 创建的是 子类）
			// 继承Thread类创建的线程类可以被多次实例化并启动多个线程，而匿名内部类通常只用于创建一次性的线程对象。
			// 使用匿名类创建 Thread 子类对象
			Thread t1 = new Thread() {
				@Override
				public void run() {
					System.out.println("使用匿名类创建 Thread 子类对象");
			   }
			};
		2. 匿名内部类创建 Runnable 子类对象
			// 使用匿名类创建 Runnable 子类对象
			Thread t2 = new Thread(new Runnable() {
				@Override
				public void run() {
					System.out.println("使用匿名类创建 Runnable 子类对象");
			   }
			});
		3. lambda 表达式创建 Runnable 子类对象
			// 使用 lambda 表达式创建 Runnable 子类对象
			Thread t3 = new Thread(() -> System.out.println("使用匿名类创建 Thread 子类对象"));
			Thread t4 = new Thread(() -> {
				System.out.println("使用匿名类创建 Thread 子类对象");
			});

	
2. 控制线程的4个常用方法
	1. sleep()
	使当前正在执行的线程暂停指定的毫秒数，也就是进入休眠的状态。
	需要注意的是，sleep 的时候要对异常进行处理。
	2. join()
	等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。
	3. setDaemon()
	// 守护线程在主线程操作完成后就会自动退出，所以不适合进行读写操作
	将此线程标记为守护线程，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。
	4. yield()
	yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。
	然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和 JVM 的线程调度策略。
3. 获取Java线程执行结果: Callable、Future、FutureTask	
	1. 有返回值的 Callable
		Callable 位于 java.util.concurrent 包下，也是一个接口，它定义了一个 call() 方法
		一般会配合 ExecutorService（后面在讲线程池的时候会细讲，这里记住就行）来使用。
		ExecutorService 是一个接口，位于 java.util.concurrent 包下，它是 Java 线程池框架的核心接口，
		用来异步执行任务。它提供了一些关键方法用来进行线程管理。
		我们通过 Executors 工具类来创建一个 ExecutorService，然后向里面提交 Callable 任务，然后通过 Future 来获取执行结果。
		ExecutorServices.submit() = Future
		使用 Runnable 的方式要比 Callable 的方式简单一些，但是 Callable 的方式可以获取执行结果，这是 Runnable 做不到的。
	2. 异步计算结果Future接口
		我们通过 Future 来获取 Callable 任务的执行结果，那么 Future 是什么呢
		Future 位于 java.util.concurrent 包下，它是一个接口：
		一共声明了5种方法: cancel()、isCanclled()、isDone()、get()、get(long timeout, TimeUnit uint)
		
		也就是说 Future 提供了三种功能：
		1）判断任务是否完成；
		2）能够中断任务；
		3）能够获取任务执行结果。
		由于 Future 只是一个接口，如果直接 new 的话，编译器是会有一个 ⚠️ 警告的，它会提醒我们最好使用 FutureTask。
		实际上，FutureTask 是 Future 接口的一个唯一实现类，我们在前面的例子中 executorService.submit() 返回的就是 FutureTask
	3. 异步执行结果FutureTask实现类
		FutureTask 类实现了 RunnableFuture 接口
		RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。
		所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。
		当需要异步执行一个计算并在稍后的某个时间点获取其结果时，就可以使用 FutureTask
		
		Future和FutureTask都能异步的获取线程执行结果，
		但是FutureTask不仅实现Future接口，并且实现了Runable接口，所以我们可以直接将FutureTask提交到线程池执行，同时也可以获取执行结果，
		但是Future仅支持获取Callable的执行结果，所以可见FutureTask功能更加全面且方便。
FutureTask底层是基于AQS实现的
4. Java线程的6种状态及切换
		操作系统的线程主要有以下三个状态：

		就绪状态(ready)：线程正在等待使用 CPU，经调度程序调用之后进入 running 状态。
		执行状态(running)：线程正在使用 CPU。
		等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如 I/O）。
5. Java线程的6种状态
		// Thread.State 源码
		public enum State {
			NEW,
			RUNNABLE,
			BLOCKED,
			WAITING,
			TIMED_WAITING,
			TERMINATED;
		}
	1) NEW
		处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的start()方法。
		*关于 start 的两个引申问题
		反复调用同一个线程的 start 方法是否可行？
		假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？

		都不行，在调用 start 之后，threadStatus 的值会改变（threadStatus !=0），再次调用 start 方法会抛出 IllegalThreadStateException 异常。
		threadStatus 为 2 代表当前线程状态为 TERMINATED（下面会讲）。
	2) Runnable
		表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。
		也就是说，Java 线程的RUNNABLE状态其实包括了操作系统线程的ready和running两个状态.
	3) BLOCKED
		阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。
		我们用 BLOCKED 状态举个生活中的例子：
		假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。
		假设你是线程 t2，你前面的那个人是线程 t1。此时 t1 占有了锁（食堂唯一的窗口），t2 正在等待锁的释放，所以此时 t2 就处于 BLOCKED 状态。
	4) WAITING
		等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。
		调用下面这 3 个方法会使线程进入等待状态：
		Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；
		Thread.join()：等待线程执行完毕，底层调用的是 Object 的 wait 方法；
		LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。LockSupport 我们在后面会细讲。
		***当线程调用wait方法时，它会释放当前持有的对象锁
	5) TIMED_WAITING
		超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。
		调用如下方法会使线程进入超时等待状态：
		Thread.sleep(long millis)：使当前线程睡眠指定时间；
		Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；
		Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；
		LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；LockSupport 我们在后面会细讲；
		LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；
	6) TERMINATED
		终止状态。此时线程已执行完毕
	***线程中断
			在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在 Java 里还没有安全方法来直接停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。
			线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。
			简单介绍下 Thread 类里提供的关于线程中断的几个方法：
			Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 flase）；
			Thread.currentThread().isInterrupted()：测试当前线程是否被中断。线程的中断状态会受这个方法的影响，调用一次可以使线程中断状态变为 true，调用两次会使这个线程的中断状态重新转为 false；
			Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。
			在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的时机中断请求，也可以完全不处理继续执行下去。
6. 通过线程组管理线程, 设置线程优先级
		Java 提供了 ThreadGroup 类来创建一组相关的线程，使线程组管理更方便。
		每个 Java 线程都有一个优先级，这个优先级会影响到操作系统为这个线程分配处理器时间的顺序。
		
1). 线程组(ThreadGroup)
		Java 用 ThreadGroup 来表示线程组，我们可以通过线程组对线程进行批量控制。

		ThreadGroup 和 Thread 的关系就如同他们的字面意思一样简单粗暴，每个 Thread 必然存在于一个 ThreadGroup 中，
		Thread 不能独立于 ThreadGroup 存在。执行main()方法的线程名字是 main，如果在 new Thread 时没有显式指定，
		那么默认将父线程（当前执行 new Thread 的线程）线程组设置为自己的线程组。
		ThreadGroup 是一个标准的向下引用的树状结构，这样设计可以防止"上级"线程被"下级"线程引用而无法有效地被 GC 回收。	
2). 线程组的常用方法及数据结构
		1) 获取当前线程的线程组的名字
			Thread.currentThread().getThreadGroup().getName()
		2) 复制线程组
			// 获取当前的线程组
			ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();
			// 复制一个线程组到一个线程数组（获取Thread信息）
			Thread[] threads = new Thread[threadGroup.activeCount()];
			threadGroup.enumerate(threads);
		3) 线程组统一异常处理
		4) 线程组的数据结构
			线程组还可以包含其他的线程组，不仅仅是线程。
			public class ThreadGroup implements Thread.UncaughtExceptionHandler {
					private final ThreadGroup parent; // 父亲ThreadGroup
					String name; // ThreadGroup 的名称
					int maxPriority; // 最大优先级
					boolean destroyed; // 是否被销毁
					boolean daemon; // 是否守护线程
					boolean vmAllowSuspension; // 是否可以中断

					int nUnstartedThreads = 0; // 还未启动的线程
					int nthreads; // ThreadGroup中线程数目
					Thread threads[]; // ThreadGroup中的线程

					int ngroups; // 线程组数目
					ThreadGroup groups[]; // 线程组数组
				}
3) 线程的优先级
			线程优先级可以指定，范围是 1~10。但并不是所有的操作系统都支持 10 级优先级的划分
			（比如有些操作系统只支持 3 级划分：低、中、高），Java 只是给操作系统一个优先级的参考值，线程最终在操作系统中的优先级还是由操作系统决定。
			Java 默认的线程优先级为 5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。
			通常情况下，高优先级的线程将会比低优先级的线程有更高的概率得到执行。Thread类的setPriority()方法可以用来设定线程的优先级。
			
			Java 中的优先级不是特别的可靠，Java 程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。
			而真正的调用顺序，是由操作系统的线程调度算法来决定的。
			
			Java 提供了一个线程调度器来监视和控制处于RUNNABLE 状态的线程。
			线程的调度策略采用抢占式的方式，优先级高的线程会比优先级低的线程有更大的几率优先执行。
			在优先级相同的情况下，会按照“先到先得”的原则执行。
			每个 Java 程序都有一个默认的主线程，就是通过 JVM 启动的第一个线程——main 线程。
			还有一种特殊的线程，叫做守护线程（Daemon），守护线程默认的优先级比较低。

			如果某线程是守护线程，那如果所有的非守护线程都结束了，这个守护线程也会自动结束。
			当所有的非守护线程结束时，守护线程会自动关闭，这就免去了还要继续关闭子线程的麻烦。
			线程默认是非守护线程，可以通过 Thread 类的 setDaemon 方法来设置为守护线程。
			
4) 线程组和线程优先级之间的关系
			所以，如果某个线程的优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
7. 进程和线程的区别
		进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。
		进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。
		进程拥有独立的内存空间，线程共享所属进程的内存空间。
		进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。
		进程间的通信比较复杂，而线程间的通信比较简单。
		进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。
8. 并发编程或者说多线程带来了哪些问题
		1) 线程安全问题
			1. 原子性
				原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
				原子操作：即不会被线程调度机制打断的操作，没有上下文切换。
			2. 可见性
				可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
				为了解决多线程的可见性问题，Java 提供了volatile这个关键字。当一个共享变量被 volatile 修饰时，
				它会保证修改的值立即更新到主存当中，这样的话，当有其他线程需要读取时，就会从内存中读到新值。
				普通的共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，因此另外一个线程读到的可能就是旧值。
				当然 Java 的锁机制如 synchronized 和 lock 也是可以保证可见性的。
			3. 活跃性问题
				活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。
				概念可能有点拗口，活跃性问题一般有这样几类：死锁，活锁，饥饿问题。
				
					死锁
				死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。
					活锁
				死锁是两个线程都在等待对方释放锁导致阻塞。而活锁的意思是线程没有阻塞，还活着呢。
				当多个线程都在运行并且都在修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。
					饥饿
				如果一个线程无其他异常却迟迟不能继续运行，那基本上是处于饥饿状态了。
				高优先级的线程一直在运行消耗 CPU，所有的低优先级线程一直处于等待；
				一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问；
			4. 性能问题
			
				前面讲到了线程安全和死锁、活锁这些问题，如果这些都没有发生，多线程并发一定比单线程串行执行快吗？答案是不一定，因为多线程有创建线程和线程上下文切换的开销。
				创建线程是直接向系统申请资源的，对操作系统来说，创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等。
				线程创建完之后，还会遇到线程上下文切换。
				CPU 是很宝贵的资源，速度非常快，为了保证雨露均沾，通常会给不同的线程分配时间片，当 CPU 从执行一个线程切换到执行另一个线程时，
				CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行线程的本地数据，程序指针等，也就是『上下文切换』。

				一般减少上下文切换的方法有：

				无锁并发编程：可以参照 ConcurrentHashMap 锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
				CAS 算法，利用 Atomic + CAS 算法来更新数据，采用乐观锁的方式，可以有效减少一部分不必要的锁竞争带来的上下文切换。
				使用最少线程：避免创建不必要的线程，如果任务很少，但创建了很多的线程，这样就会造成大量的线程都处于等待状态。
				协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
9. JMM(Java内存模型)
		Java 内存模型 (JMM) 主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
		主要目的是为了解决由于编译器优化、处理器优化和缓存系统等导致的可见性、原子性和有序性。
		Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括以下几个部分：
		方法区、堆、栈、本地方法栈(native)、程序计数器
		并发编程的线程之间存在两个问题：
		线程间如何通信？即：线程之间以何种机制来交换信息
		线程间如何同步？即：线程以何种机制来控制不同线程间发生的相对顺序
		有两种并发模型可以解决这两个问题：
			1) 消息传递并发模型
			2) 共享内存并发模型
		1) 什么是共享变量
			对于每一个线程来说，栈都是私有的，而堆是共有的。
			也就是说，在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，
			也就不会有内存可见性的问题，也不受内存模型的影响。而在堆中的变量是共享的，一般称之为共享变量。
			所以，内存可见性针对的是堆中的共享变量。
		2) 内存可见性问题是如何发生的
			既然堆是共享的，为什么在堆中会有内存不可见问题
			这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为 CPU 访问缓存区比访问内存要快得多。
			线程之间的共享变量存在于主存中，每个线程都有一个私有的本地内存，存储了该线程的读、写共享变量的副本。
			本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。
			Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主存之间的抽象关系
			
				1. 所有的共享变量都存在主存中。
				2. 每个线程都保存了一份该线程使用到的共享变量的副本。
				3. 如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤：
				    1. 线程 A 将本地内存 A 中更新过的共享变量刷新到主存中去。
				    2. 线程 B 到主存中去读取线程 A 之前已经更新过的共享变量。
				所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主存。
				注意，根据 JMM 的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主存中读取。
				主内存：Java堆中对象实例数据部分，对应于物理硬件的内存
				工作内存：Java栈中的部分区域，优先存储于寄存器和高速缓存
				所以线程 B 并不是直接去主存中读取共享变量的值，而是先在本地内存 B 中找到这个共享变量，
				发现这个共享变量已经被更新了，然后本地内存 B 去主存中读取这个共享变量的新值，并拷贝到本地内存 B 中，最后线程 B 再读取本地内存 B 中的新值。
		3) 如何保证内存可见性?
			那么怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。JMM 通过控制主存与每个线程的本地内存之间的交互，来提供内存可见性保证。
			Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。
			在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员更方便地理解，设计者提出了 happens-before 的概念（下文会细讲），它更加简单易懂，
			从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则，以及这些规则的具体实现方法。
		4) JMM 与 Java 运行时内存区域的区别
			前面提到了 JMM 和 Java 运行时内存区域的划分，这两者既有差别又有联系：
					区别
				两者是不同的概念。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，
				围绕原子性、有序性、可见性等展开。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时必要的内存划分。
					联系
				都存在私有数据区域和共享数据区域。一般来说，JMM 中的主存属于共享数据区域，包含了堆和方法区；
				同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。
				总结一下：
				Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括以下几个部分：
				方法区：存储了每一个类的结构信息，如运行时常量池、字段和方法数据、构造方法和普通方法的字节码内容。
				堆：几乎所有的对象实例以及数组都在这里分配内存。这是 Java 内存管理的主要区域。
				栈：每一个线程有一个私有的栈，每一次方法调用都会创建一个新的栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息。所有的栈帧都是在方法调用和方法执行完成之后创建和销毁的。
				本地方法栈：与栈类似，不过本地方法栈为 JVM 使用到的 native 方法服务。
				程序计数器：每个线程都有一个独立的程序计数器，用于指示当前线程执行到了字节码的哪一行。
				Java 内存模型 (JMM) 主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
				它涵盖的主题包括变量的可见性、指令重排、原子操作等，旨在解决由于多线程并发编程带来的一些问题。
				可见性：当一个线程修改了共享变量的值，这个新值对于其他线程来说可以立即知道。
				原子性：一个或多个操作在整个过程中，不会被其他的线程或者操作所打断，这些操作是一个整体，要么都执行，要么都不执行。
				有序性：程序执行的顺序按照代码的先后顺序执行的。
		5) JMM与重排序
				重排序有哪几种？
			指令重排一般分为以下三种：
			1. 编译器优化重排，编译器在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
			2. 指令并行重排，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性
			(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。
			3. 内存系统重排，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去
			可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。
			指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。
		6) JMM与顺序一致性模型
			当程序未正确同步的时候，就可能存在数据竞争。
			数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。
			如果程序中包含了数据竞争，那么运行的结果往往充满了不确定性，比如读发生在了写之前，可能就会读到错误的值；如果一个线程能够正确同步，那么就不存在数据竞争。
			Java 内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：如果程序是正确同步的，程序的执行将具有顺序一致性。即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。
			这里的同步包括使用 volatile、final、synchronized 等关键字实现的同步。
			如果我们开发者没有正确使用volatile、final、synchronized 等关键字，那么即便是使用了同步，JMM 也不会有内存可见性的保证，很可能会导致程序出错，并且不可重现，很难排查。
			
				什么是顺序一致性模型？
			顺序一致性模型是一个理想化的理论参考模型，它为程序提供了极强的内存可见性保证。顺序一致性模型有两大特性：
			一个线程中的所有操作必须按照程序的顺序（即 Java 代码的顺序）来执行。
			不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是原子性的，且立刻对所有线程可见。
			
				JMM 为什么不保证顺序一致性？
			顺序一致性模型中的每个操作必须立即对任意线程可见。
			但是 JMM 没有这样的保证。
			
			JMM 的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门。
			对于未同步的多线程，JMM 只提供最小安全性：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。
			为了实现这个安全性，JVM 在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。
			JMM 没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么 JMM 需要禁止大量的优化，对程序的执行性能会产生很大的影响。
			未同步程序在 JMM 和顺序一致性内存模型中的执行特性有如下差异：
			顺序一致性保证单线程内的操作会按程序的顺序执行；JMM 不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是 JMM 保证单线程下的重排序不影响执行结果）
			顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。（因为 JMM 不保证所有操作立即可见）
			顺序一致性模型保证对所有的内存读写操作都具有原子性，而 JMM 不保证对 64 位的 long 型和 double 型变量的写操作具有原子性。
			
		7) JMM与happens-before	
			一方面，我们开发者需要 JMM 提供一个强大的内存模型来编写代码；另一方面，编译器和处理器希望 JMM 对它们的束缚越少越好，这样它们就可以尽可能多的做优化来提高性能，希望的是一个弱的内存模型。
			JMM 考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。
			对于我们开发者来说，JMM 提供了happens-before 规则（JSR-133 规范），满足了我们的诉求——简单易懂，并且提供了足够强的内存可见性保证。 换言之，我们开发者只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。
			JMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程内，也可以是不同的线程种。
			happens-before 关系的定义如下：
			1. 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
			2. 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。
			如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。
			happens-before 关系本质上和 as-if-serial 语义是一回事。
			as-if-serial 语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before 关系保证正确同步的多线程程序的执行结果不被重排序改变。
			总之，如果操作 A happens-before 操作 B，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。
			#happens-before 关系有哪些？
			在 Java 中，有以下天然的 happens-before 关系：
			1. 程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。
			2. 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。
			3. volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
			4. 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
			5. start 规则：如果线程 A 执行操作 ThreadB.start()启动线程 B，那么 A 线程的 ThreadB.start()操作 happens-before 于线程 B 中的任意操作。
			6. join 规则：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。
		8) 重排序有两类，JMM 对这两类重排序有不同的策略：
			会改变程序执行结果的重排序，比如 A -> C，JMM 要求编译器和处理器都禁止这种重排序。
			不会改变程序执行结果的重排序，比如 A -> B，JMM 对编译器和处理器不做要求，允许这种重排序。
			#小结
			1. Java 内存模型（JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。
			2. Java 内存模型（JMM）主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
			3. Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括方法区、堆、栈、本地方法栈、程序计数器。
			4. 指令重排是为了提高 CPU 性能，但是可能会导致一些问题，比如多线程环境下的内存可见性问题。
			5. happens-before 规则是 JMM 提供的强大的内存可见性保证，只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。
10. Java volatile关键字解析
		volatile关键字可以修饰在类变量或者实例变量上，不能修饰在方法参数，局部变量，实例常量以及类常量上。
	volatile 是 Java 中的一个关键字，用于确保多线程环境中的变量可见性和禁止指令重排序。当一个变量被声明为 volatile，它保证了以下两点：
		可见性：当一个线程修改了一个 volatile 变量的值，新值对其他线程是立即可见的。这确保了当一个线程读取一个 volatile 变量时，它总会看到最近被写入的值，即使这个写入操作是在另一个线程中完成的。
		禁止指令重排序：编译器和处理器在优化代码时可能会重排序指令以提高性能。但是，volatile 关键字可以禁止这种可能导致数据不一致的重排序。
			然而，尽管 volatile 提供了可见性和禁止重排序的保证，但它并不保证原子性。这意味着 volatile 不能用于解决所有的并发问题，尤其是那些涉及到复合操作（如递增一个计数器）的情况。
			使用场景：
			当一个变量需要在多个线程之间共享并且其值经常变化时，可以考虑使用 volatile。
			当需要确保一个变量的变化对其他线程立即可见时，volatile 是有用的。
			注意事项：
			不要过度依赖 volatile。它主要用于简单的同步需求，对于更复杂的并发场景，通常需要使用更强大的同步机制，如 synchronized 或 java.util.concurrent 包中的工具类。
			volatile 不能替代锁或其他同步机制。例如，它不能保证复合操作的原子性。
			总的来说，volatile 是一个有用的工具，但它有其局限性和使用场景。在使用它时，需要清楚其工作原理和限制，以确保正确地解决并发问题。
	原子性: 读, 改, 写. read-modify-write(count++ 操作实际上包含了三个步骤)
		volatile 可以保证可见性，但不保证原子性：
	当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；
	这个写操作会导致其他线程中的 volatile 变量缓存无效。
	1. volatile会禁止重排序	
		当我们使用 volatile 关键字来修饰一个变量时，Java 内存模型会插入内存屏障（一个处理器指令，可以对 CPU 或编译器重排序做出约束）来确保以下两点：
		写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存。
		读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取。
		换句话说：
		当程序执行到 volatile 变量的读操作或者写操作时，在其前面操作的更改肯定已经全部进行，且结果对后面的操作可见；在其后面的操作肯定还没有进行；
		在进行指令优化时，不能将 volatile 变量的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。
	    也就是说，执行到 volatile 变量时，其前面的所有语句都必须执行完，后面所有得语句都未执行。且前面语句的结果对 volatile 变量及其后面语句可见。
	2. volatile不适用的场景
		1) 自增++, 不是原子性操作
		01、采用 synchronized，把 inc++ 拎出来单独加 synchronized 关键字
		02、采用 Lock，通过重入锁 ReentrantLock 对 inc++ 加锁
		03、采用原子类 AtomicInteger
	3. volatile实现单例模式的双重锁
		"双重检查锁定"（double-checked locking）实现的单例模式（Singleton Pattern）
		使用 volatile 关键字是为了防止 m_penguin = new penguin() 这一步被指令重排序。实际上，new penguin() 这一步分为三个子步骤：
		1. 分配对象的内存空间。
		2. 初始化对象。
		3. 将 m_penguin 指向分配的内存空间。
	                     小结
		volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层 volatile 是采用“内存屏障”来实现的。
		观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码就能发现，加入 volatile 关键字时，会多出一个 lock 前缀指令，
		lock 前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供 3 个功能：
		1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
		2. 它会强制将对缓存的修改操作立即写入主存；
		3. 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。
		最后，我们学习了 volatile 不适用的场景，以及解决的方法，并解释了双重检查锁定实现的单例模式为何需要使用 volatile。
11. synchronized关键字
		synchronized 关键字最主要有以下 3 种应用方式：
		1. 同步方法，为当前对象（this）加锁，进入同步代码前要获得当前对象的锁；
		2. 同步静态方法，为当前类加锁（锁的是 Class 对象），进入同步代码前要获得当前类的锁；
		3. 同步代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。			
	1) synchronized同步方法
		通过在方法声明中加入 synchronized 关键字，可以保证在任意时刻，只有一个线程能执行该方法。
		注意：一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，
					所以无法访问该对象的其他 synchronized 方法，但是其他线程还是可以访问该对象的其他非 synchronized 方法。
		每个对象都有一个对象锁，不同的对象，他们的锁不会互相影响。
		解决这种问题的的方式:
		是将 synchronized 作用于静态的 increase 方法，这样的话，对象锁就锁的是当前的类，由于无论创建多少个对象，类永远只有一个，所有在这样的情况下对象锁就是唯一的。
	2) synchronized同步静态方法
		当 synchronized 同步静态方法时，锁的是当前类的 Class 对象，不属于某个对象。
		当前类的 Class 对象锁被获取，不影响实例对象锁的获取，两者互不影响，本质上是 this 和 Class 的不同。
		由于静态成员变量不专属于任何一个对象，因此通过 Class 锁可以控制静态成员变量的并发操作。
	3) synchronized同步代码块
		某些情况下，我们编写的方法代码量比较多，存在一些比较耗时的操作，而需要同步的代码块只有一小部分，
		如果直接对整个方法进行同步，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹。
	4) synchronized禁止指令重排
		在 Java 内存模型中，监视器锁规则是一种 happens-before 规则，它规定了对一个监视器锁（monitor lock）或者叫做互斥锁的解锁操作 happens-before 于随后对这个锁的加锁操作。
		简单来说，这意味着在一个线程释放某个锁之后，另一个线程获得同一把锁的时候，前一个线程在释放锁时所做的所有修改对后一个线程都是可见的。
	5) synchronized属于可重入锁
		从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，
		将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功。
		synchronized 就是可重入锁，因此一个线程调用 synchronized 方法的同时，在其方法体内部调用该对象另一个 synchronized 方法是允许的
	**临界区/临界资源
		在同一段时间只有一条线程访问.
12. synchronized的4种状态
	1) Java 多线程的锁都是基于对象的
		Class 对象是一种特殊的 Java 对象，代表了程序中的类和接口。Java 中的每个类型（包括类、接口、数组以及基础类型）在 JVM 中都有一个唯一的 Class 对象与之对应。
		这个 Class 对象被创建的时机是在 JVM 加载类时，由 JVM 自动完成。
		Class 对象中包含了与类相关的很多信息，如类的名称、类的父类、类实现的接口、类的构造方法、类的方法、类的字段等等。这些信息通常被称为元数据（metadata）。
		可以通过 Class 对象来获取类的元数据，甚至动态地创建类的实例、调用类的方法、访问类的字段等。这就是Java 的反射（Reflection）机制。
		所以我们常说的类锁，其实就是 Class 对象的锁。
	2) 锁的基本用法
	我们通常使用synchronized关键字来给一段代码或一个方法上锁
		关键字在实例方法上，锁为当前实例
		关键字在静态方法上，锁为当前Class对象
		关键字在代码块上，锁为括号里面的对象
		所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果synchronized关键字在方法上，那临界区就是整个方法内部。而如果是 synchronized 代码块，那临界区就指的是代码块内部的区域。
	3) 锁的四种状态及锁降级
		几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件就比较苛刻了，
		锁降级发生在 Stop The World（Java 垃圾回收中的一个重要概念，JVM 篇会细讲）期间，当 JVM 进入安全点的时候，会检查是否有闲置的锁，然后进行降级。
		在 JDK 1.6 以前，所有的锁都是”重量级“锁, 效率低, 性能差.
		重量级锁因为涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。
		1. 无锁状态
			无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，很好理解。
		2. 偏向锁状态
			在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了
			偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，
			该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。
		3. 轻量级锁状态
			轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。
			轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。
			轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。
		4. 重量级锁状态
			 synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本身依赖底层的操作系统的 Mutex Lock来实现。
			 操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系统 Mutex Lock来实现的锁称为重量级锁。为了优化synchonized，引入了轻量级锁，偏向锁。
	4) 对象的锁放在什么地方
		1. 当对象状态为偏向锁时，Mark Word存储的是偏向的线程 ID；
		2. 当状态为轻量级锁时，Mark Word存储的是指向线程栈中Lock Record的指针；
		3. 当状态为重量级锁时，Mark Word为指向堆中的 monitor（监视器）对象的指针。
		***在 Java 中，监视器（monitor）是一种同步工具，用于保护共享数据，避免多线程并发访问导致数据不一致。在 Java 中，每个对象都有一个内置的监视器。
		监视器包括两个重要部分，一个是锁，一个是等待/通知机制，后者是通过 Object 类中的wait(), notify(), notifyAll()等方法实现的（我们会在讲Condition和生产者-消费者模式）详细地讲。
	5) 锁的升级流程
		每一个线程在准备获取共享资源时：
		第一步，检查 MarkWord 里面是不是放的自己的 ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。
		第二步，如果 MarkWord 不是自己的 ThreadId，锁升级，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空。
		第三步，两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作，
		把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord。
		第四步，第三步中成功执行 CAS 的获得资源，失败的则进入自旋 。
		第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。
		第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。***自旋：不断尝试去获取锁，一般用循环来实现。
					小结
		1. Java 中的每一个对象都可以作为一个锁，Java 中的锁都是基于对象的。
		2. synchronized 关键字可以用来修饰方法和代码块，它可以保证在同一时刻最多只有一个线程执行该段代码。
		3. synchronized 关键字在修饰方法时，锁为当前实例对象；在修饰静态方法时，锁为当前 Class 对象；在修饰代码块时，锁为括号里面的对象。
		4. Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁“。在 Java 6 以前，所有的锁都是”重量级“锁。
		所以在 Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。
		5. 偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
		也就是说，偏向锁在资源无竞争情况下消除了同步语句，连 CAS 操作都不做了，提高了程序的运行性能。
		6. 轻量级锁是通过 CAS 操作和自旋来实现的，如果自旋失败，则会升级为重量级锁。
		7. 重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。
13. 乐观锁CAS
	CAS（Compare-and-Swap）是一种被广泛应用在并发控制中的算法，它是一种乐观锁的实现方式。CAS 全称为“比较并交换”，是一种无锁的原子操作。
	CAS 的全称是：比较并交换（Compare And Swap）。在 CAS 中，有这样三个值：
	V：要更新的变量(var)
	E：预期值(expected)
	N：新值(new)
	比较并交换的过程如下：
	判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。
	这里的预期值 E 本质上指的是“旧值”。
		****CAS 的三大问题
		尽管 CAS 提供了一种有效的同步手段，但也存在一些问题，主要有以下三个：ABA 问题、长时间自旋、多个共享变量的原子操作。
			所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。
	    在开发中，我们要根据实际情况来选择使用 CAS 还是使用锁。
14. 抽象队列同步器AQS
	1) 什么是抽象队列同步器
		AQS是AbstractQueuedSynchronizer的简称, 即抽象队列同步器, 从字面上可以理解
		1. 抽象类: 抽象类, 只实现一些主要逻辑, 有些方法由子类实现
		2. 队列: 使用先进先出(FIFO)的队列存储数据
		3. 同步: 实现了同步功能
	2) AQS有什么用
		AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器，
			比如 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等，都是基于 AQS 的。
		也可以利用 AQS 轻松定制专属的同步器，只要实现它的几个protected方法就可以了。
	3) AQS的数据结构
		AQS 内部使用了一个 volatile 的变量 state 来作为资源的标识。
		同时定义了几个获取和改变 state 的 protected 方法，子类可以覆盖这些方法来实现自己的逻辑
		这三种操作均是原子操作，其中 compareAndSetState 的实现依赖于 Unsafe 的 compareAndSwapInt() 方法。
		AQS 内部使用了一个先进先出（FIFO）的双端队列，并使用了两个引用 head 和 tail 用于标识队列的头部和尾部。
		但它并不直接储存线程，而是储存拥有线程的 Node 节点。
	4) AQS 的 Node 节点
		资源有两种共享模式，或者说两种同步方式：
		独占模式（Exclusive）：资源是独占的，一次只能有一个线程获取。如 ReentrantLock。
		共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如 Semaphore/CountDownLatch（戳链接直达，后面会细讲）。
		一般情况下，子类只需要根据需求实现其中一种模式就可以，当然也有同时实现两种模式的同步类，如 ReadWriteLock。
		     小结
	AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器，
	比如我们提到的 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。
	当然了，我们也可以利用 AQS 轻松定制专属的同步器，只要实现它的几个protected方法就可以了。
	来个互斥锁（同一时刻只允许一个线程持有锁）。
15. 锁分类和JUC
	1) 前面我们介绍了基于对象的原生锁——synchronized，实际上，Java 在java.util.concurrent（JUC）包下，还为我们提供了更多的锁类和锁接口（尤其是子包 locks 下），它们有更强大的功能或更牛逼的性能。
		来看看synchronized的不足之处吧: 
		如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，同一时间只能有一个线程执行。
		synchronized 无法知道线程有没有成功获取到锁。
		使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待。
			临界区（Critical Section）是多线程中一个 非常重要的概念，指的是在代码中访问共享资源的那部分，且同一时刻只能有一个线程能访问的代码。
			多个线程同时访问临界区的资源如果没有任何同步（加锁）操作，会导致资源的状态不可预测和不一致，从而产生所谓的“竞态条件”(Race Condition)。
			在许多并发控制策略中，例如互斥锁 synchronized，目标就是确保任何时候只有一个线程进入临界区。
		不过，synchronized 的这些不足之处都可以通过 JUC 包下的其他锁来弥补，下面先来看一下锁的分类吧。
	2) 锁的几种分类
		1. 乐观锁和悲观锁
			1) 乐观锁:
				乐观锁在 Java 中是通过无锁编程来实现的，最常采用的是CAS 算法，Java 原子类的递增操作就通过 CAS 自旋实现的。
				
			2) 悲观锁:
				对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
				Java 中，synchronized 关键字 是最典型的悲观锁。
			**********
			3) CAS和自旋:     --Compare ans Swap
						如果未能立即获取到锁，它会持续循环尝试获取，而不是进入阻塞状态。这种机制避免了线程上下文切换带来的开销。
			4) CAS 算法涉及到三个操作数：
				需要读写的内存值 V。
				进行比较的值 A。
				要写入的新值 B。
				当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
				之前提到 JUC 包中的原子类，就是通过 CAS 实现的乐观锁，原子类 AtomicInteger
			5) 适用场景
			悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
			乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。
		2. 自旋锁 VS 适应性自旋锁
			切换线程消耗CPU资源
					自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。
					反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是 10 次，可以使用-XX:PreBlockSpin 来更改）没有成功获得锁，就应当挂起线程。
					自旋锁的实现原理同样也是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。
			自旋锁在 JDK1.4.2 中引入，使用-XX:+UseSpinning来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。
			自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。
			如果在同一个锁对象上，自旋刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功的，
			进而它将允许自旋等待更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。
		3. 无锁偏向锁轻量级锁重量级锁
			这四种锁是专门针对 synchronized 的，我们在synchronized 锁的到底是什么一文中已经详细地介绍过，这里就不再赘述了。
		4. 可重入锁和非可重入锁
			1) 可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提：锁的是同一个对象或者 class），
				不会因为之前已经获取过还没释放而阻塞。Java 中ReentrantLock（后面会细讲，戳链接直达）和synchronized都是可重入锁，可重入锁的一个优点就是可以一定程度避免死锁。
			2) 首先ReentrantLock和 NonReentrantLock 都继承了父类AQS，其父类 AQS 中维护了一个同步状态 status 来计数重入次数，status 初始值为 0。
		5. 公平锁与非公平锁
			这里的“公平”，其实通俗意义来说就是“先来后到”，也就是 FIFO。
			如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。
			一般情况下，非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况。所以要根据实际的需求来选择非公平锁和公平锁。
			ReentrantLock 支持非公平锁和公平锁两种。
		6. 读写锁和排它锁
			1) synchronized 和 ReentrantLock，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。
			2) 读写锁
				读写锁可以在同一时刻允许多个读线程访问。Java 提供了 ReentrantReadWriteLock类作为读写锁的默认实现，
				内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。
				*********注意，即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞。
			3) 排它锁
				排它锁也叫独享锁，如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程既能读数据又能修改数据。
				synchronized 和 ReentrantLock
			4) 共享锁
				与排它锁对应的，就是共享锁，指该锁可被多个线程所持有。如果线程 T 对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。
				独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。
		3)  JUC 包下的锁
			众所周知，JDK 中关于并发的类大多都在 JUC 包下。
			看名字就知道，locks 包是提供一些并发锁的工具类的。
			前面我们介绍的 AQS（AbstractQueuedSynchronizer）就是在这个包下。
			1) 抽象类 AQS/AQLS/AOS
				AbstractQueuedSynchronizer: JDK 1.5, 提供了一个“队列同步器”的基本功能实现。
				AbstractQueuedLongSynchronizer: JDK 1.6, 将AQS中资源从int 类型变成了Long 类型.
				AbstractOwnableSynchronizer: JDK 1.6, AQS和AQLS都继承了AOS, AOS用于表示锁与持有者之间的关系(独占模式)
			2) 接口 Condition/Lock/ReadWriteLock
				1. locks 包下共有三个接口：Condition、Lock、ReadWriteLock。
					其中，Lock 和 ReadWriteLock 从名字就可以看得出来，分别是锁和读写锁的意思。
				2. Lock 接口里面有一些获取锁和释放锁的方法声明，
					而 ReadWriteLock 里面只有两个方法，分别返回“读锁”和“写锁”
				3. Lock 接口中有一个方法可以获得一个Condition
					每个对象都可以用Object的wait/notify方法来实现等待/通知机制。而 Condition 接口也提供了类似 Object 的方法，可以配合Lock来实现等待/通知模式。
				4. Condition 和 Object 的 wait/notify 基本相似。其中，Condition 的 await 方法对应的是 Object 的 wait 方法，而 Condition 的signal/signalAll方法则对应 Object 的 notify/notifyAll()。
					但 Condition 类似于 Object 的等待/通知机制的加强版
				5. 可重入锁ReentrantLock
					ReentrantLock是 Lock 接口的默认实现，实现了锁的基本功能。
					在 ReentrantLock 的构造方法里，可以传入一个boolean类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过isFair()方法来查看。
				6. 读写锁ReentrantReadWriteLock
					ReentrantReadWriteLock 是 ReadWriteLock 接口的默认实现。
					它与 ReentrantLock 的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。
					ReentrantReadWriteLock 实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。
					我们称这种现象为“写饥饿”，将在下文的 StampedLock 类继续讨论这个问题。
				7. 锁王StampedLock
					StampedLock 类是 Java 8 才发布的，也是 Doug Lea 大神所写，有人称它为锁的性能之王。
					StampedLock 没有实现 Lock 接口和 ReadWriteLock 接口，但它实现了“读写锁”的功能，并且性能比 ReentrantReadWriteLock 更高。StampedLock 还把读锁分为了“乐观读锁”和“悲观读锁”两种。
					前面提到了 ReentrantReadWriteLock 会发生“写饥饿”的现象，但 StampedLock 不会。它是怎么做到的呢？
					它的核心思想在于，在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和 CAS 自旋的思想一样。
					这种操作方式决定了 StampedLock 在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。
					****区别
					1、可重入性：ReentrantReadWriteLock 支持可重入，即在一个线程中可以多次获取读锁或写锁。StampedLock 则不支持可重入。
					2、乐观读锁：StampedLock 提供了乐观读锁机制，允许一个线程在没有任何写入操作发生的情况下读取数据，从而提高了性能。而 ReentrantReadWriteLock 没有提供这样的机制。
					3、锁降级：StampedLock 提供了从写锁到读锁的降级功能，这在某些场景下可以提供额外的灵活性。ReentrantReadWriteLock 不直接提供这样的功能。
					4、API 复杂性：由于提供了乐观读锁和锁降级功能，StampedLock 的 API 相对复杂一些，需要更小心地使用以避免死锁和其他问题。ReentrantReadWriteLock 的 API 相对更直观和容易使用。
					综上所述，StampedLock 提供了更高的性能和灵活性，但也带来了更复杂的使用方式。ReentrantReadWriteLock 则相对简单和直观，特别适用于没有高并发读的场景。
	 4) JUC包下的其他工具类
			locks 包下的锁接口和锁类介绍完了，我们这里再讲一些 JUC 包下的其他工具类，
			比如 Semaphore、CountDownLatch、CyclicBarrier、Exchanger、Phaser 等（这些在通信工具类中也会细讲）。
			1) Semaphore
				Semaphore 是一个计数信号量，它的作用是限制可以访问某些资源（物理或逻辑的）的线程数目。Semaphore 的构造方法可以指定信号量的数目，也可以指定是否是公平的。
				Semaphore 有两个主要的方法：acquire()和release()。acquire()方法会尝试获取一个信号量，如果获取不到，就会阻塞当前线程，直到有线程释放信号量。release()方法会释放一个信号量，释放之后，会唤醒一个等待的线程。
				Semaphore 还有一个tryAcquire()方法，它会尝试获取一个信号量，如果获取不到，就会返回 false，不会阻塞当前线程。
				Semaphore 用来控制同时访问某个特定资源的操作数量，它并不保证线程安全，所以要保证线程安全，还需要加上同步锁。
			2) CountDownLatch
				CountDownLatch 是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。
				CountDownLatch 有一个计数器，可以通过countDown()方法对计数器的数目进行减一操作，也可以通过await()方法来阻塞当前线程，直到计数器的值为 0。
				CountDownLatch 一般用来控制线程等待，它可以让某个线程一直等待直到倒计时结束，再开始执行。
			3) CyclicBarrier
				CyclicBarrier 是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点（common barrier point）。
				CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 sheet 保存一个账户近一年的每笔银行流水，
					现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，
					最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。
				CyclicBarrier 的计数器可以通过reset()方法重置，所以它能处理循环使用的场景。比如，我们将一个大任务分成 10 个小任务，用 10 个线程分别执行这 10 个小任务，
					当 10 个小任务都执行完之后，再合并这 10 个小任务的结果，这个时候就可以用 CyclicBarrier 来实现。
				CyclicBarrier 还有一个有参构造方法，可以指定一个 Runnable，这个 Runnable 会在 CyclicBarrier 的计数器为 0 的时候执行，用来完成更复杂的任务。
			4) Exchanger
					只能是2个线程,它不支持更多的线程之间互换数据。
				Exchanger 是一个用于线程间协作的工具类。Exchanger 用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。
				这两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange 方法，它会一直等待第二个线程也执行 exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。
				Exchanger 可以用于遗传算法、校对工作和数据同步等场景。
			5) Phaser
				Phaser 是一个同步工具类，它可以让多个线程在某个时刻一起完成任务。
				Phaser 可以理解为一个线程的计数器，它可以将这个计数器加一或减一。当这个计数器的值为 0 的时候，所有调用await()方法而在等待的线程就会继续执行。
				Phaser 的计数器可以被动态地更新，也可以被动态地增加或减少。Phaser 还提供了一些方法来帮助我们更好地控制线程的到达。
								小结
			本文介绍了 JUC 包下的锁接口和锁类，包括 Lock、ReadWriteLock、Condition、ReentrantLock、ReentrantReadWriteLock、StampedLock(优化读写锁) 等。
			还介绍了 JUC 包下的其他工具类，包括 Semaphore、CountDownLatch、CyclicBarrier、Exchanger、Phaser 等。
			JUC 包下的锁接口和锁类，可以说是 Java 并发编程的核心，也是面试中经常会问到的知识点。所以，一定要掌握好。
******线程按顺序执行:
					1. Thread: join()和wait(), notify()
					2. JUC下的工具类: Semaphore, Countdownlatch 和 CyclicBarrier
					3. JUC下的Future接口: Java并发包java.util.concurrent中的一个重要组件，它用于表示异步计算的结果。Future对象通常是通过提交任务到ExecutorService来获得的，这样可以在不阻塞当前线程的情况下启动一个异步任务。
						FutureTask是Future和Runnable接口的实现类，它可以将一个Callable或Runnable任务包装成一个Future对象。
						CompletableFuture是Java 8中引入的一个类，它实现了Future和CompletionStage接口，提供了函数式编程的方式来处理异步计算的结果。
						与Future和FutureTask相比，CompletableFuture提供了更丰富的API，可以更方便地处理异步任务的组合和链式调用。它支持链式编程，可以通过.thenApply(), .thenAccept(), .thenCompose()等方法来连接多个异步任务。
16. 重入锁ReentrantLock
		1) 深入理解Java并发重入锁ReentrantLock
			ReentrantLock 重入锁，是实现Lock 接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源重复加锁，即当前线程获取该锁后再次获取不会被阻塞。
			要想支持重入性，就要解决两个问题：
			在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；
			由于锁会被获取 n 次，那么只有锁在被释放同样的 n 次之后，该锁才算是完全释放成功。
			我们知道，同步组件主要是通过重写 AQS 的几个 protected 方法来表达自己的同步语义。
		2) ReentrantLock 与 synchronized
			1. ReentrantLock 是一个类，而 synchronized 是 Java 中的关键字；
			2. ReentrantLock 可以实现多路选择通知（可以绑定多个 Condition），而 synchronized 只能通过 wait 和 notify/notifyAll 方法唤醒一个线程或者唤醒全部线程（单路通知）；
			3. ReentrantLock 必须手动释放锁。通常需要在 finally 块中调用 unlock 方法以确保锁被正确释放。
			4. synchronized 会自动释放锁，当同步块执行完毕时，由 JVM 自动释放，不需要手动操作。
			5. ReentrantLock: 通常提供更好的性能，特别是在高竞争环境下。
			6. synchronized: 在某些情况下，性能可能稍差一些，但随着 JDK 版本的升级，性能差距已经不大了。
		3) lock相比synchronized
			灵活性： Lock接口提供了更多的锁定控制方法，允许你更精细地控制锁定的行为。例如，你可以使用tryLock()方法尝试获取锁，可以设置超时时间，还可以使用lockInterruptibly()方法来实现可中断的锁定。
			可中断性： Lock接口的锁定方法允许线程在等待锁时被中断，而synchronized块不支持线程的中断等待。
			公平性： Lock接口的一些实现类允许你指定锁的公平性，以确保等待时间最长的线程优先获取锁。在synchronized块中，锁的获取是不公平的，没有公平性选项。
17. ReetrantReadWriteLock
		1) ReentrantReadWriteLock 是 Java 的一种读写锁，它允许多个读线程同时访问，但只允许一个写线程访问（会阻塞所有的读写线程）。这种锁的设计可以提高性能，特别是在读操作的数量远远超过写操作的情况下。
			在并发场景中，为了解决线程安全问题，我们通常会使用关键字 synchronized 或者 JUC 包中实现了 Lock 接口的 ReentrantLock。但它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。
			而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性，而如果在这种业务场景下，依然使用独占锁的话，很显然会出现性能瓶颈。
			针对这种读多写少的情况，Java 提供了另外一个实现 Lock 接口的 ReentrantReadWriteLock——读写锁。
		2) 读写锁的特性：
			1）公平性选择：支持非公平性（默认）和公平的锁获取方式，非公平的吞吐量优于公平；
			2）重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；
			3）锁降级：写锁降级是一种允许写锁转换为读锁的过程。通常的顺序是：
				获取写锁：线程首先获取写锁，确保在修改数据时排它访问。
				获取读锁：在写锁保持的同时，线程可以再次获取读锁。
				释放写锁：线程保持读锁的同时释放写锁。
				释放读锁：最后线程释放读锁。
				这样，写锁就降级为读锁，允许其他线程进行并发读取，但仍然排除其他线程的写操作
							小结
		ReentrantReadWriteLock 是 Java 的一种读写锁，它允许多个读线程同时访问，但只允许一个写线程访问，或者阻塞所有的读写线程。这种锁的设计可以提高性能，特别是在数据结构中，读操作的数量远远超过写操作的情况下。
		读写锁的实现主要是通过重写 AQS 的 tryAcquire 方法和 tryRelease 方法实现的，读锁和写锁的获取和释放都是通过这两个方法实现的。
		读写锁支持锁降级，遵循按照获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁，不支持锁升级。
18. 等待通知条件Condition	
		Condition 接口是 Java 并发编程中一个重要的组件，用于线程间的协调和通信。它通常与锁（特别是 ReentrantLock）一起使用，为线程提供了一种等待某个条件成真的机制，并
		允许其他线程在该条件变化时通知等待线程。这为线程间的协调提供了更灵活、更强大的工具。
		    private static ReentrantLock lock = new ReentrantLock();
			private static Condition condition = lock.newCondition();
			condition.await(); condition.signalAll();
19. 线程阻塞唤醒类LockSupport
		1) LockSupprot 用来阻塞和唤醒线程，底层实现依赖于 Unsafe 类
		2) 阻塞线程
				1. void park()：阻塞当前线程，如果调用 unpark 方法或线程被中断，则该线程将变得可运行。请注意，park 不会抛出 InterruptedException，因此线程必须单独检查其中断状态。
				2. void park(Object blocker)：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。
				3. void parkNanos(long nanos)：阻塞当前线程一定的纳秒时间，或直到被 unpark 调用，或线程被中断。
				4. void parkNanos(Object blocker, long nanos)：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。
				5. void parkUntil(long deadline)：阻塞当前线程直到某个指定的截止时间（以毫秒为单位），或直到被 unpark 调用，或线程被中断。
				6. void parkUntil(Object blocker, long deadline)：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。
		 3) 唤醒线程
				void unpark(Thread thread)：唤醒一个由 park 方法阻塞的线程。如果该线程未被阻塞，那么下一次调用 park 时将立即返回。这允许“先发制人”式的唤醒机制。
				实际上，LockSupport 阻塞和唤醒线程的功能依赖于 sun.misc.Unsafe，这是一个很底层的类，后面这篇文章会细讲，比如 LockSupport 的 park 方法是通过 unsafe.park() 方法实现的。
		4) Dump 线程
			"Dump 线程"通常是指获取线程的当前状态和调用堆栈的详细快照。这可以提供关于线程正在执行什么操作以及线程在代码的哪个部分的重要信息。
			线程转储可以通过各种方式获得，例如使用 Java 的 jstack 工具，或从 Java VisualVM、Java Mission Control 等工具获取。
		5) 与synchronized的区别
			1. synchronized 会使线程阻塞，线程会进入 BLOCKED 状态，而调用 LockSupprt 方法阻塞线程会使线程进入到 WAITING 状态。
		6) 面试题
			有 3 个独立的线程，一个只会输出 A，一个只会输出 B，一个只会输出 C，在三个线程启动的情况下，请用合理的方式让他们按顺序打印 ABCABC。
			        t1 = new Thread(() -> {
						for (int i = 0; i < 2; i++) {
							LockSupport.park();
							System.out.print("A");
							LockSupport.unpark(t2);
						}
					});
							小结
		LockSupport 提供了一种更底层和灵活的线程调度方式。它不依赖于同步块或特定的锁对象。
		可以用于构建更复杂的同步结构，例如自定义锁或并发容器。LockSupport.park 与 LockSupport.unpark 的组合使得线程之间的精确控制变得更容易，而不需要复杂的同步逻辑和对象监视。
20. Java的并发容器ConcurrentHashMap、阻塞队列、CopyOnWrite容器等
		1) Java 的并发集合容器提供了在多线程环境中高效访问和操作的数据结构。这些容器通过内部的同步机制实现了线程安全，使得开发者无需显式同步代码就能在并发环境下安全使用，
			比如说：ConcurrentHashMap、阻塞队列和 CopyOnWrite 容器等。
			java.util 包下提供了一些容器类（集合框架），其中 Vector 和 Hashtable 是线程安全的，但实现方式比较粗暴，通过在方法上加「sychronized」关键字实现。
			但即便是 Vector 这样线程安全的类，在应对多线程的复合操作时也需要在客户端继续加锁以保证原子性。
		2) 并发Map
			1. ConcurrentMap接口
				ConcurrentMap 接口继承了 Map 接口，在 Map 接口的基础上又定义了四个方法
				1)) putIfAbsent： 与原有 put 方法不同的是，putIfAbsent 如果插入的 key 相同，则不替换原有的 value 值；
				2)) remove： 与原有 remove 方法不同的是，新 remove 方法中增加了对 value 的判断，如果要删除的 key-value 不能与 Map 中原有的 key-value 对应上，则不会删除该元素;
				3)) replace(K,V,V)： 增加了对 value 值的判断，如果 key-oldValue 能与 Map 中原有的 key-value 对应上，才进行替换操作；
				4)) replace(K,V)： 与上面的 replace 不同的是，此 replace 不会对 Map 中原有的 key-value 进行比较，如果 key 存在则直接替换；
			2. ConcurrentHashMap
				ConcurrentHashMap 同 HashMap 一样，也是基于散列表的 map，但是它提供了一种与 Hashtable 完全不同的加锁策略，提供了更高效的并发性和伸缩性。
			3. ConcurrentSkipListMap
				ConcurrentNavigableMap 接口继承了 NavigableMap 接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。
				ConcurrentNavigableMap 接口继承了 NavigableMap 接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。
				ConcurrentNavigableMap 接口的主要实现类是 ConcurrentSkipListMap 类。从名字上来看，它的底层使用的是跳表（SkipList）。跳表是一种”空间换时间“的数据结构，可以使用 CAS 来保证并发安全性。
				与 ConcurrentHashMap 的读密集操作相比，ConcurrentSkipListMap 的读和写操作的性能相对较低。这是由其数据结构导致的，因为跳表的插入和删除需要更复杂的指针操作。
				然而，ConcurrentSkipListMap 提供了有序性，这是 ConcurrentHashMap 所没有的。
				ConcurrentSkipListMap 适用于需要线程安全的同时又需要元素有序的场合。如果不需要有序，ConcurrentHashMap 可能是更好的选择，因为它通常具有更高的性能。
		3) 并发Queue
			JDK 并没有提供线程安全的 List 类，因为对 List 来说，很难去开发一个通用并且没有并发瓶颈的线程安全的 List。因为即使简单的读操作，比如 contains()，也需要再搜索的时候锁住整个 list。
			所以退一步，JDK 提供了队列和双端队列的线程安全类：ConcurrentLinkedQueue 和 ConcurrentLinkedDeque。因为队列相对于 List 来说，有更多的限制。这两个类是使用 CAS 来实现线程安全的。
		4) 并发Set
			ConcurrentSkipListSet 是线程安全的有序集合。底层是使用 ConcurrentSkipListMap 来实现。
			谷歌的 Guava实现了一个线程安全的 ConcurrentHashSet
			Set 日常开发中用的并不多，所以这里就不展开细讲了。
		5) 阻塞队列
			1. 什么阻塞队列
				我们假设一种场景，生产者一直生产资源，消费者一直消费资源（后面会细讲，戳链接直达），资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的生产者-消费者模式。
				该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。
				我们自己 coding 实现这个模式的时候，因为需要让多个线程操作共享变量（即资源），所以很容易引发线程安全问题，造成重复消费和死锁，尤其是生产者和消费者存在多个的情况。
				另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个等待-唤醒逻辑都需要自己实现。
				这么容易出错的事情，JDK 当然帮我们做啦，这就是阻塞队列（BlockingQueue），你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。
				
				BlockingQueue 是 Java util.concurrent 包下重要的数据结构，区别于普通的队列，BlockingQueue 提供了线程安全的队列访问方式，并发包下很多高级同步类的实现都是基于 BlockingQueue 实现的。
				
				BlockingQueue 一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。BlockingQueue 就是存放元素的容器。
			
			2. BlockingQueue 的操作方法:
				阻塞队列提供了四组不同的方法用于插入、移除、检查元素：
				方法\处理方式	抛出异常  	返回特殊值	  一直阻塞	         超时退出
					插入方法	          add(e)	      offer(e)	      put(e)	           offer(e,time,unit)
					移除方法	        remove()	   poll()	      take()            	poll(time,unit)
					检查方法	       element()	   peek()	          -	                      -
				1. 抛出异常：如果操作无法立即执行，会抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出 IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出 NoSuchElementException 异常 。
				2. 返回特殊值：如果操作无法立即执行，会返回一个特殊值，通常是 true / false。
				3. 一直阻塞：如果操作无法立即执行，则一直阻塞或者响应中断。
				4. 超时退出：如果操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 true / false。
					注意：
				1. 不能往阻塞队列中插入 null，会抛出空指针异常。
				2. 可以访问阻塞队列中的任意元素，调用 remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。
			3. BlockingQueue 的实现类
					1. ArrayBlockingQueue
						由数组结构组成的有界阻塞队列。内部结构是数组，具有数组的特性。
						public ArrayBlockingQueue(int capacity, boolean fair){
							 //..省略代码
							}
						可以初始化队列大小，一旦初始化将不能改变。构造方法中的 fair 表示控制对象的内部锁是否采用公平锁，默认是非公平锁。
					2. LinkedBlockingQueue
						由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是Integer.MAX_VALUE，也可以指定大小。此队列按照先进先出的原则对元素进行排序。
					3. DelayQueue
						该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。
						DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。
					4. PriorityBlockingQueue
						基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），内部控制线程同步的锁采用的是非公平锁。	
					5. SynchronousQueue
					这个队列比较特殊，没有任何内部容量，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。
					需要区别容量为 1 的 ArrayBlockingQueue、LinkedBlockingQueue。
					以下方法的返回值，可以帮助理解这个队列：

						iterator() 永远返回空，因为里面没有东西
						peek() 永远返回 null
						put() 往 queue 放进去一个 element 以后就一直 wait 直到有其他 thread 进来把这个 element 取走。
						offer() 往 queue 里放一个 element 后立即返回，如果碰巧这个 element 被另一个 thread 取走了，offer 方法返回 true，认为 offer 成功；否则返回 false。
						take() 取出并且 remove 掉 queue 里的 element，取不到东西他会一直等。
						poll() 取出并且 remove 掉 queue 里的 element，只有到碰巧另外一个线程正在往 queue 里 offer 数据或者 put 数据的时候，该方法才会取到东西。否则立即返回 null。
						isEmpty() 永远返回 true
						remove()&removeAll() 永远返回 false
									*****注意
					PriorityBlockingQueue不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时阻塞数据的消费者。
					因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。对于使用默认大小的LinkedBlockingQueue也是一样的。
			4. CopyOnWrite容器
					在聊 CopyOnWrite 容器之前我们先来谈谈什么是 CopyOnWrite 机制，CopyOnWrite 是计算机设计领域的一种优化策略，
					也是一种在并发场景下常用的设计思想——写入时复制。
					什么是写入时复制呢？
					就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。
					CopyOnWrite 容器即写时复制的容器，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行 copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。
					这样做的好处在于，我们可以在并发的场景下对容器进行"读操作"而不需要"加锁"，从而达到读写分离的目的。从 JDK 1.5 开始 Java 并发包里提供了两个使用 CopyOnWrite 机制实现的并发容器，
					分别是 CopyOnWriteArrayList 和 CopyOnWriteArraySet（不常用）。
																		小结
			本文主要介绍了并发包中的三个重要的容器类:
			1. Map: ConcurrentHashMap, ConcurrentSkipListMap(有序)
				List: 难做到并发, 因为即使简单的读操作，比如 contains()，也需要再搜索的时候锁住整个 list。
				并发Queue: ConcurrentLinkedQueue 和 ConcurrentLinkedDeque
			2. 阻塞队列: ArrayBlockingQueue, LinkedBlockingQueue, DelayQueue, PriorityBlockingQueue, SynchronousQueue(大小为1)
			3. CopyOnWrite 容器: CopyOnWriteArrayList, CopyOnWriteArraySet       ***"读操作"而不需要"加锁"
			*********Map 用于存储键值对，阻塞队列用于生产者-消费者模型，而 CopyOnWrite 容器用于“读多写少”的并发场景。
21. ConcurrentHashMap/吊打Java并发面试官之ConcurrentHashMap（线程安全的哈希表）
		线程安全的哈希表
			ConcurrentHashMap 是线程安全的，支持完全并发的读取，并且有很多线程可以同时执行写入。在早期版本（例如 JDK 1.7）中，ConcurrentHashMap 使用分段锁技术。
			整个哈希表被分成一些段（Segment），每个段独立加锁。这样，在不同段上的操作可以并发进行。从 JDK 1.8 开始，ConcurrentHashMap 的内部实现有了很大的变化。
			它放弃了分段锁技术，转而采用了更先进的并发控制策略，如 CAS 操作和红黑树等，进一步提高了并发性能。
			由于并发性质，ConcurrentHashMap 的大小计算可能不是精确的，但通常足够接近真实值。
22. ConcurrentLinkedQueue/吊打Java并发面试官之线程安全的队列实现ConcurrentLinkedQueue
		ConcurrentLinkedQueue 是 java.util.concurrent（JUC） 包下的一个线程安全的队列实现。基于非阻塞算法（Michael-Scott 非阻塞算法的一种变体），
		这意味着 ConcurrentLinkedQueue 不再使用传统的锁机制来保护数据安全，而是依靠底层原子的操作（如 CAS）来实现。
		ConcurrentLinkedQueue 是一种先进先出（FIFO，First-In-First-Out）的队列，它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。
		头是最先加入的，尾是最近加入的。该队列不允许 null 元素。
		ConcurrentLinkedQueue 采用了 HOPS 的设计，即 head 和 tail 是延迟更新的，这种设计的主要目的是减小多线程环境下的争用，并提高性能。
		ConcurrentLinkedQueue 的 offer 方法用于在队列尾部插入一个元素。如果成功添加元素，则返回 true。
		ConcurrentLinkedQueue 的 poll 方法用于检索并删除队列的头部元素。如果队列为空，则返回 null。
		ConcurrentLinkedQueue 的 isEmpty 方法用于检索队列是否为空。
		ConcurrentLinkedQueue 的 size 方法用于返回队列的大小。
23. BlockingQueue(接口)/吊打Java并发面试官之阻塞队列BlockingQueue
		BlockingQueue 是 Java 中的一个接口，它代表了一个线程安全的队列，不仅可以由多个线程并发访问，还添加了等待/通知机制，
		以便在队列为空时阻塞获取元素的线程，直到队列变得可用，或者在队列满时阻塞插入元素的线程，直到队列变得可用。
		最常用的"生产者-消费者"问题中，队列通常被视作线程间的数据容器，生产者将“生产”出来的数据放入数据容器，消费者从“数据容器”中获取数据，
		这样，生产者线程和消费者线程就解耦了，各自只需要专注自己的业务即可。
		阻塞队列（BlockingQueue）被广泛用于“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除方法。
		当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。
		1) ArrayBolckingQueue
			BlockingQueue 接口的实现类有 ArrayBlockingQueue、DelayQueue、LinkedBlockingDeque、LinkedBlockingQueue、LinkedTransferQueue、PriorityBlockingQueue、SynchronousQueue 等，我们先从 ArrayBlockingQueue 说起。
			ArrayBlockingQueue 它是一个基于数组的有界阻塞队列：
			有界：ArrayBlockingQueue 的大小是在构造时就确定了，并且在之后不能更改。这个界限提供了流量控制，有助于资源的合理使用。
			FIFO：队列操作符合先进先出的原则。
			当队列容量满时，尝试将元素放入队列将导致阻塞；尝试从一个空的队列取出元素也会阻塞。
			需要注意的是，ArrayBlockingQueue 并不能保证绝对的公平，所谓公平是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 ArrayBlockingQueue。
			这是因为还有其他系统级别的因素，如线程调度，可能会影响到实际的执行顺序。如果需要公平的 ArrayBlockingQueue，可在声明的时候设置公平标志为 true:
					private static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10, true);
		2) LinkedBlockingQueue
24.  CopyOnWriteArrayList/吊打Java并发面试官之CopyOnWriteArrayList
		学过 ArrayList 的小伙伴应该记得，ArrayList 是一个线程不安全的容器，如果在多线程环境下使用，需要手动加锁，或者使用 Collections.synchronizedList() 方法将其转换为线程安全的容器。
		否则，将会出现 ConcurrentModificationException 异常。
		于是，Doug Lea 大师为我们提供了一个并发版本的 ArrayList——CopyOnWriteArrayList。
		CopyOnWriteArrayList 是线程安全的，可以在多线程环境下使用。CopyOnWriteArrayList 遵循写时复制的原则，每当对列表进行修改（例如添加、删除或更改元素）时，
		都会创建列表的一个新副本，这个新副本会替换旧的列表，而对旧列表的所有读取操作仍然可以继续。
		由于在修改时创建了新的副本，所以读取操作不需要锁定。这使得在多读取者和少写入者的情况下读取操作非常高效。当然，由于每次写操作都会创建一个新的数组副本，所以会增加存储和时间的开销。如果写操作非常频繁，性能会受到影响。
		
		1) 什么是CopyOnWrite
				读写锁:
			读写锁 ReentrantReadWriteLock: 读写锁是通过读写分离的思想来实现的，即读写锁将读写操作分别加锁，从而实现读写操作的并发执行。
			读写锁也存在一些问题，比如说在写锁执行后，读线程会被阻塞，直到写锁被释放后读线程才有机会获取到锁从而读到最新的数据，
			站在读线程的角度来看，读线程在任何时候都能获取到最新的数据，满足数据实时性。
				CopyOnWriteList:
			CopyOnWriteArrayList 是通过 Copy-On-Write(COW)，即写时复制的思想来通过延时更新的策略实现数据的最终一致性，并且能够保证读线程间不阻塞。
			当然，这要牺牲数据的实时性。
			
			通俗的讲，CopyOnWrite 就是当我们往一个容器添加元素的时候，不直接往容器中添加，而是先复制出一个新的容器，然后在新的容器里添加元素，
			添加完之后，再将原容器的引用指向新的容器。多个线程在读的时候，不需要加锁，因为当前容器不会添加任何元素。
		2) CopyOnWriteArrayList 的缺点
			CopyOnWrite 容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要特别注意。
			内存占用问题：因为 CopyOnWrite 的写时复制机制，在进行写操作的时候，内存里会同时有两个对象，旧的对象和新写入的对象，分析 add 方法的时候大家都看到了。
			如果这些对象占用的内存比较大，比如说 200M 左右，那么再写入 100M 数据进去，内存就会占用 600M，那么这时候就会造成频繁的 minor GC 和 major GC。
			数据一致性问题：CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。
			所以如果你希望写入的的数据，马上能读到，请不要使用 CopyOnWrite 容器，最好通过 ReentrantReadWriteLock 自定义一个的列表。	
		3) 我们来比较一下 CopyOnWrite 和读写锁。
				相同点：
			两者都是通过读写分离的思想来实现的；
			读线程间是互不阻塞的
				不同点：
			为了实现数据实时性，在写锁被获取后，读线程会阻塞；或者当读锁被获取后，写线程会阻塞，从而解决“脏读”的问题。
			而 CopyOnWrite 对数据的更新是写时复制的，因此读线程是延时感知的，单不会存在阻塞的情况。
********************并发事务所产生的3个问题
									1. 脏读: 读到了其他事务未提交的数据
									2. 不可重复读: 在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。
									3. 幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。
										更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。
									不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。
********************事务的隔离级别
										上述所说的"脏读"，“不可重复读”，"幻读"这些问题，其实就是数据库读一致性问题，必须由数据库提供的事务隔离机制来进行解决。
									1. 读未提交: 没有隔离效果
									2. 读已提交: 解决脏读, Oracle默认隔离级别
									3. 可重复读: 解决脏读, 不可重复读. MySQL默认事务隔离级别.
									4. 串行化: 解决脏读, 不可重复读, 幻读. 读的时候加共享锁, 其他事务可以并发读不能写. 写的时候加上排他锁/独占锁/写锁, 其他事务不能并发写也不能并发读.
			小结:
				CopyOnWriteArrayList 是一个线程安全的变体，它是 Java 的 ArrayList 类的并发版本。这个类的线程安全是通过一个简单但强大的想法实现的：每当列表修改时，就创建列表的一个新副本。
				CopyOnWriteArrayList 适用于读操作远远大于写操作的场景，比如说缓存。因为 CopyOnWriteArrayList 采用写时复制的思想，所以写操作的性能较低，因此不适合写操作频繁的场景。
				CopyOnWriteArrayList 也存在一些缺点，比如说内存占用问题和数据一致性问题，所以在开发的时候需要特别注意。
25. ThreadLocal/吊打Java并发面试官之ThreadLocal
			是 Java 中提供的一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离，用于解决多线程中共享对象的线程安全问题。
			通常，我们会使用 synchronzed 关键字 或者 lock 来控制线程对临界区资源的同步顺序，但这种加锁的方式会让未获取到锁的线程进行阻塞，很显然，这种方式的时间效率不会特别高。
			线程安全问题的核心在于多个线程会对同一个临界区的共享资源进行访问，那如果每个线程都拥有自己的“共享资源”，各用各的，互不影响，这样就不会出现线程安全的问题了，对吧？
			事实上，这就是一种“空间换时间”的思想，每个线程拥有自己的“共享资源”，虽然内存占用变大了，但由于不需要同步，也就减少了线程可能存在的阻塞问题，从而提高时间上的效率。
			不过，ThreadLocal 并不在 java.util.concurrent 并发包下，而是在 java.lang 包下，但我更倾向于把它当作是一种并发容器。
			顾名思义，
			ThreadLocal 就是线程的“本地变量”，即每个线程都拥有该变量的一个副本，达到人手一份的目的，这样就可以避免共享资源的竞争。
			***JUC包: java.util.concurrent, java.util.concurrent.locks, java.util.concurrent.atomic, 一些并发容器.
			1) ThreadLocal的使用场景
				1. 用于保存用户登录信息，这样在同一个线程中的任何地方都可以获取到登录信息。
				2. 用于保存数据库连接、Session 对象等，这样在同一个线程中的任何地方都可以获取到数据库连接、Session 对象等。
				3. 用于保存事务上下文，这样在同一个线程中的任何地方都可以获取到事务上下文。
				4. 用于保存线程中的变量，这样在同一个线程中的任何地方都可以获取到线程中的变量。
			示例定义了一个UserAuthenticationService类，该类使用ThreadLocal来保存与当前线程关联的用户登录信息。
			假设用户已经通过身份验证，将用户对象存储在currentUser ThreadLocal变量中。
			getCurrentUser方法用于检索与当前线程关联的用户信息。由于使用了ThreadLocal，因此不同的线程可以同时登录不同的用户，而不会相互干扰。
						小结:
	ThreadLocal 是一个非常有用的工具类，它可以用于保存线程中的变量，这样在同一个线程中的任何地方都可以获取到线程中的变量。但是，ThreadLocal 也是一个非常容易被误用的工具类，如果没有使用好，就可能会造成内存泄漏的问题。
	ThreadLocalMap 是 ThreadLocal 的核心，它是一个以 ThreadLocal 实例为 key，任意对象为 value 的哈希表。ThreadLocalMap 使用开放地址法来处理哈希冲突，它的初始容量为 16，加载因子为 2/3，扩容时会将容量扩大为原来的两倍。
	ThreadLocal内存泄露:
		1.ThreadLocal变量没有被明确的移除。
		2.ThreadLocal变量一直存在于ThreadLocalMap中。
	解决:
		1.使用ThreadLocal.remove()方法
		2.使用不可变对象
		3.使用弱引用
		4.使用线程池
26. 线程池
	一、什么是线程池
		线程池其实是一种池化的技术实现，池化技术的核心思想就是实现资源的复用，避免资源的重复创建和销毁带来的性能开销。线程池可以管理一堆线程，让线程执行完任务之后不进行销毁，而是继续去处理其它线程已经提交的任务。
		使用线程池的好处
		1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
		2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
		3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
	二、线程池的构造
		Java 主要是通过构建 ThreadPoolExecutor 来创建线程池的。接下来我们看一下线程池是如何构造出来的
		1. corePoolSize：线程池中用来工作的核心线程数量。
		2. maximumPoolSize：最大线程数，线程池允许创建的最大线程数。
		3. keepAliveTime：临时线程在空闲状态下的存活时间 (临时线程数=最大线程数-核心线程数)
		4. unit：keepAliveTime 的时间单位。
		5. workQueue：任务队列，是一个阻塞队列，当线程数达到核心线程数后，会将任务存储在阻塞队列中。
		6. threadFactory ：线程池内部创建线程所用的工厂。
		7. handler：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理任务。
		线程池的构造其实很简单，就是传入一堆参数，然后进行简单的赋值操作。

	三、线程池的运行原理
		此时来了一个任务:
			1. 线程数 < corePoolSize ----> ThreadFactory 创建一个线程来执行这个任务
			2. 线程数 >= corePoolSize ----> 任务放入阻塞队列
			3. 阻塞队列满了, 任务放入阻塞队列失败
			判断 线程数 < maximumPoolSize ----> 创建非核心线程来执行提交的任务
			*****从这可以看出，先提交的任务不一定先执行。
			4. 线程数 > maximumPoolSize ----> 执行拒绝策略
				RejectedExecutionHandler 对象，来处理这个任务。
				
			JDK 自带的 RejectedExecutionHandler 实现有 4 种: 
				1. AbortPolicy：丢弃任务，抛出运行时异常
				2. CallerRunsPolicy：由提交任务的线程来执行任务
				3. DiscardPolicy：丢弃这个任务，但是不抛异常
				4. DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务
			线程池创建的时候，如果不指定拒绝策略就默认是 AbortPolicy 策略。
	四、线程池中线程实现复用的原理
		线程在线程池内部其实被封装成了一个 Worker 对象, Worker 继承了 AQS，也就是具有一定锁的特性。
		runWorker 内部使用了 while 死循环，当第一个任务执行完之后，会不断地通过 getTask 方法获取任务，只要能获取到任务，就会调用 run 方法继续执行任务，这就是线程能够复用的主要原因。
		但是如果从 getTask 获取不到方法的话，就会调用 finally 中的 processWorkerExit 方法，将线程退出。
		这里有个一个细节就是，因为 Worker 继承了 AQS，每次在执行任务之前都会调用 Worker 的 lock 方法，执行完任务之后，会调用 unlock 方法，这样做的目的就可以通过 Woker 的加锁状态判断出当前线程是否正在执行任务。
		如果想知道线程是否正在执行任务，只需要调用 Woker 的 tryLock 方法，根据是否加锁成功就能判断，加锁成功说明当前线程没有加锁，也就没有执行任务了，在调用 shutdown 方法关闭线程池的时候，
		就时用这种方式来判断线程有没有在执行任务，如果没有的话，会尝试打断没有执行任务的线程。
	五、线程是如何获取任务以及如何实现超时的
		线程达到了 keepAliveTime 还没有获取到任务，就会返回 null，一旦 getTask 方法返回 null，线程就会退出。
	六、线程池的 5 种状态
		1. private static final int RUNNING    = -1 << COUNT_BITS;
		2. private static final int SHUTDOWN   =  0 << COUNT_BITS;
		3. private static final int STOP       =  1 << COUNT_BITS;
		4. private static final int TIDYING    =  2 << COUNT_BITS;
		5. private static final int TERMINATED =  3 << COUNT_BITS;
	七、线程池的关闭
		线程池提供了 shutdown 和 shutdownNow 两个方法来关闭线程池。
		shutdown: 只想玩队列中任务
		shutdownNow: 所有线程执行结束
		线程全部执行完毕了，池中线程为0，马上会进入终结状态
	八、线程池的监控
		在项目中使用线程池的时候，一般需要对线程池进行监控，方便出问题的时候快速定位。线程池本身提供了一些方法来获取线程池的运行状态。
		getCompletedTaskCount：已经执行完成的任务数量
		getLargestPoolSize：线程池里曾经创建过的最大的线程数量。这个主要是用来判断线程是否满过。
		getActiveCount：获取正在执行任务的线程数据
		getPoolSize：获取当前线程池中线程数量的大小
		除了线程池提供的上述已经实现的方法，同时线程池也预留了很多扩展方法。比如在 runWorker 方法里面，执行任务之前会回调 beforeExecute 方法，
		执行任务之后会回调 afterExecute 方法，而这些方法默认都是空实现，可以自己继承 ThreadPoolExecutor 来重写这些方法，实现自己想要的功能。
	九、线程池的使用场景
		1. 模拟一个简单的Web服务器，接受请求并使用线程池进行处理。
			private static final int NTHREADS = 100;
			private static final ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);
			while(tur){
			Runnable request = new Runnable() {
					public void run() {
					}
				};
			exec.execute(request);
			}
		2. 使用线程池进行并行的数值计算。
			private static final int NTHREADS = 4;
			private static final ExecutorService exec = Executors.newFixedThreadPool(NTHREADS);
			Callable<Double> task = new Callable<Double>() {
				@Override
				public Double call() {
					// 这里模拟一些数值计算
					return Math.random() * 100;
				}
			};
			List<Future<Double>> results = new ArrayList<>();
			for (int i = 0; i < 10; i++) {
				results.add(exec.submit(task));
			}

			for (Future<Double> result : results) {
				try {
					System.out.println(result.get());
				} catch (InterruptedException | ExecutionException e) {
					e.printStackTrace();
				}
			}

			exec.shutdown();
		3. 异步任务处理
			private static final ExecutorService exec = Executors.newCachedThreadPool();
			exec.execute(() -> {
            // 执行某些异步任务
            System.out.println("Async task started");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Async task completed");
        });

        System.out.println("Main thread continues to execute other operations.");
        exec.shutdown();
-----------------
execute和submit的区别 :
											1. execute只能提交Runnable类型的任务，无返回值。
												submit既能提交Runable类型的任务，返回值为null，也能提交Callable类型的任务，返回值为Future。
											
											2. execute会直接抛出任务执行时异常，submit则不会抛出异常，但可以通过Future的get方法将任务执行时的异常重新抛出。
******************************************************
					1. Executor接口
					2. ExecutorService是Java中对线程池定义的一个接口，它java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法
						ExecutorService继承了Executor接口
						区别:
						1. Executor接口是Java中的一个简单接口，它只定义了一个方法execute(Runnable command)，用于执行传入的Runnable任务。这意味着Executor接口只负责提交任务，而不关注任务的执行结果。
						2. ExecutorService接口是Executor接口的子接口，继承了Executor的功能，并进行了扩展。它提供了submit()方法，该方法不仅可以接受Runnable对象，还可以接受Callable对象。
						Callable对象与Runnable类似，但能够返回执行结果或抛出异常。因此，ExecutorService不仅负责提交任务，还可以通过返回的Future对象获取任务的执行结果。
					3. Executors: 	
						Executors 是 Java 并发包 java.util.concurrent 中的一个非常有用的工厂类，它提供了一系列静态方法，
						用于创建并返回各种不同类型的线程池执行器（ExecutorService）和计划任务执行器（ScheduledExecutorService）。
						这些线程池执行器和计划任务执行器都是预先配置好的，可以根据需要执行提交的任务。
						直接使用这些默认配置的线程池可能会导致资源泄露或其他问题。
						例如，newFixedThreadPool 和 newCachedThreadPool 方法创建的线程池在默认情况下允许无限制地创建线程，这可能导致 OutOfMemoryError。
							1. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。核心线程数无限大
							2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。队列的容量默认无限大
							3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。maximumPoolSize则是int最大值
								计划线程池使用的是DelayedWordQueue，它默认大小是16，但是可以动态增长，最大值则是int的最大值
								定长线程池和单线程线程都使用LinkedBlockingQueue，而LinkedBlockingQueue默认的大小是int的最大值
							
							4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
					4. AbstractExecutorService
						实现了ExecutorService接口
						AbstractExecutorService是一个抽象类，因此它不能直接实例化。在实际使用中，通常是通过继承它的子类，如ThreadPoolExecutor或ScheduledThreadPoolExecutor，来创建和使用线程池。
					5. ScheduledExecutorService
						ScheduledExecutorService 是 Java 并发包 java.util.concurrent 中的一个接口，它扩展了 ExecutorService 接口，主要用于在给定的延迟后运行命令，或者定期地执行命令。
						ScheduledExecutorService 提供了一种灵活的方式来安排任务的执行时间。
					6. ThreadPoolExecutor
						简单地并行执行任务，不关心任务的执行时间，那么ThreadPoolExecutor是一个合适的选择。
					7. ScheduledThreadPoolExecutor
						如果你需要按照特定的时间间隔或延迟执行任务，比如定时检查系统状态、定期发送邮件等，那么ScheduledThreadPoolExecutor则更为适用。
							ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(5);
							ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
							// 初始延迟0秒，之后每次任务执行完后等待2秒再执行  
							executor.scheduleWithFixedDelay(fixedDelayTask, 0, 2, TimeUnit.SECONDS);
							// 初始延迟0秒，之后每隔1秒执行一次  
							executor.scheduleAtFixedRate(fixedRateTask, 0, 1, TimeUnit.SECONDS);
							// 在5秒后执行一次性任务  
							executor.schedule(oneTimeTask, 5, TimeUnit.SECONDS);
******************************************************
十、Executors 构建线程池以及问题分析
		虽然 JDK 提供了快速创建线程池的方法，但其实不推荐使用 Executors 来创建线程池，因为从上面构造线程池的代码可以看出，
		newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，实际使用中出现任务过多时会导致内存溢出；
		newCachedThreadPool 线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，可能机器负载过高导致服务宕机。
十一、实际项目中如何合理的自定义线程池
	通过 Executors 这个工具类来创建的线程池其实都无法满足实际的使用场景，那么在实际的项目中，到底该如何构造线程池呢，该如何合理的设置参数？
	1. 线程数
	CPU 密集型：指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为 
							CPU 核心数+1。
	IO 密集型：当执行任务需要大量的 io，比如磁盘 io，网络 io，可能会存在大量的阻塞，所以在 IO 密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 
						2*CPU 核心数
				Java 中用来获取 CPU 核心数的方法是：Runtime.getRuntime().availableProcessors();
	2. 线程工厂
		一般建议自定义线程工厂，构建线程的时候设置线程的名称，这样在查日志的时候就方便知道是哪个线程执行的代码。
	3. 有界队列
		一般需要设置有界队列的大小，比如 LinkedBlockingQueue 在构造的时候可以传入参数来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的 oom。
	例子:
		1. Web服务器通常需要处理I/O操作，比如网络I/O，因此它们被视为I/O密集型任务。因此，我们将线程数设置为2 * CPU核心数。

		public class SimpleWebServer {
			private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
			private static final int CORE_POOL_SIZE = 2 * CPU_COUNT;
			private static final int MAX_POOL_SIZE = 2 * CPU_COUNT + 1;

			private static final ThreadPoolExecutor exec = new ThreadPoolExecutor(
					CORE_POOL_SIZE,                                       // 核心线程数
					MAX_POOL_SIZE,                                        // 最大线程数
					60L,						                                          // 超出核心线程数的线程最大存活时间
					TimeUnit.SECONDS,                                  //  最大存活时间的单位
					new LinkedBlockingQueue<>(1000)     //  存放任务的阻塞队列
			);

			public static void main(String[] args) {
				while (true) {
					Runnable request = () -> System.out.println("Request handled by " + Thread.currentThread().getName());

					exec.execute(request);
				}
			}
		}
	2. 并行计算
	并行计算任务主要用于计算，没有I/O阻塞，所以它们是CPU密集型的。线程数设置为CPU核心数 + 1。
		public class ParallelCalculation {
			private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
			private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
			private static final int MAX_POOL_SIZE = CPU_COUNT * 2;

			private static final ThreadPoolExecutor exec = new ThreadPoolExecutor(
					CORE_POOL_SIZE,                                       // 核心线程数
					MAX_POOL_SIZE,                                        // 最大线程数
					10L,						                                          // 超出核心线程数的线程最大存活时间
					TimeUnit.SECONDS,                                  //  最大存活时间的单位
					new LinkedBlockingQueue<>(1000)     //  存放任务的阻塞队列
			);

			public static void main(String[] args) {
				Callable<Double> task = () -> Math.random() * 100;

				List<Future<Double>> results = new ArrayList<>();
				for (int i = 0; i < 10; i++) {
					results.add(exec.submit(task));
				}

				for (Future<Double> result : results) {
					try {
						System.out.println(result.get());
					} catch (InterruptedException | ExecutionException e) {
						e.printStackTrace();
					}
				}

				exec.shutdown();
			}
		}
		3. MyThreadFactory implements ThreadFactory
											在调用ThreadPoolExecutor时，我们也可以不传递ThreadFactory，内部会默认创建一个ThreadFactory的实例
											DefaultThreadFactory 无参构造函数生成了线程名称前缀，在创建线程实例时，拼接该线程名称
											可以自定义ThreadFactory
											既然可以不指定ThreadFactory，为何要自定义呢？
											最重要的一个作用就是设置线程名称，多线程调试起来本来就费劲，如果没有标识符，那就更难了。所以这个功能还是很重要的，并且也是编码规范中推荐的。
		4. RejectedExecutionHandler handler
			1. AbortPolicy:  丢弃任务并抛出RejectedExecutionException异常。
			2. DiscardPolicy：也是丢弃任务，但是不抛出异常。
			3. DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
			4. CallerRunsPolicy：只要线程池不关闭，该策略直接在调用者线程中，运行当前被丢弃的任务, 由提交任务的线程来执行任务
				这4中策略不友好，最好自己定义拒绝策略，实现RejectedExecutionHandler接口
				1. 默认是AbortPolicy （直接抛出异常）
				2. ThreadPoolExecutor t = new ThreadPoolExecutor(
											3, 3, 5, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2)
											,Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());
																										new ThreadPoolExecutor.DiscardPolicy());
																										new ThreadPoolExecutor.DiscardOldestPolicy());
																										new ThreadPoolExecutor.CallerRunsPolicy());
				3. 实现RejectedExecutionHandler接口
总结:
	线程池主要是通过阻塞队列来实现的，线程池的使用场景主要是异步或者多线程处理任务的场景。
	线程池的使用可以通过 Executors 来快速创建，但是不推荐使用，因为 Executors 创建的线程池都有一些缺陷，
	比如无界队列可能导致内存溢出，无限大的线程数可能导致机器负载过高。
	所以在实际的项目中，建议自定义线程池 ThreadPoolExecutor，根据业务场景来合理的设置线程数，队列大小等参数。
27. 深入剖析Java定时任务ScheduledThreadPoolExecutor
		1. executor.schedule() // 一次性任务
		    executor.scheduleAtFixedRate() // 开始延迟m秒, 每隔n秒执行一次任务
			executor.scheduleAtFixedRate() // 开始延迟m秒, 任务完成后隔n秒执行一次任务
		2. ScheduledThreadPoolExecutor 
			使用一个无界阻塞队列, DelayedWorkQueue()
		3. 在ScheduledThreadPoolExecutor中，由于使用的是无界队列，ThreadPoolExecutor中maximumPoolSize参数是无效的（因为线程数到达corePoolSize后，新增的任务会放到队列中）。
		4. Timer和ScheduledThreadPoolExecutor(n)的区别
			在Java中，Timer和ScheduledThreadPoolExecutor都是用于执行定时或周期性任务的工具，但它们之间存在一些关键的区别。以下是它们之间的主要差异：
			1. 线程池管理：
				Timer：Timer内部使用单个后台线程来执行所有定时任务。这意味着所有任务都是串行执行的，如果一个任务执行时间过长，将会影响到其他任务的执行时间。
				ScheduledThreadPoolExecutor：ScheduledThreadPoolExecutor是一个线程池，它可以根据需要创建多个线程来执行定时任务。这意味着任务可以并发执行，提高了任务的执行效率。
			2. 任务执行精度：
				Timer：由于Timer只使用一个线程，因此如果任务执行时间过长，可能会影响到定时任务的精度。
				ScheduledThreadPoolExecutor：由于可以并发执行任务，ScheduledThreadPoolExecutor通常能提供更好的任务执行精度。
			3. 异常处理：
				Timer：如果TimerTask抛出了未检查的异常，Timer将会停止所有任务的执行。这意味着一个任务的失败可能会导致整个Timer的崩溃。
				ScheduledThreadPoolExecutor：如果某个任务抛出了异常，它只会影响该任务的执行，而不会影响到线程池中的其他任务。
			4. 灵活性和扩展性：
				Timer：Timer的API相对简单，但功能也有限。它主要用于简单的定时任务。
				ScheduledThreadPoolExecutor：ScheduledThreadPoolExecutor提供了更多的API和方法，可以更灵活地管理定时任务，如设置核心线程数、最大线程数、队列容量等。这使得它在处理大量或复杂的定时任务时更加适用。
			5. 任务取消和调度：
				Timer：取消任务和重新调度任务在Timer中相对较为简单，但功能有限。
				ScheduledThreadPoolExecutor：ScheduledThreadPoolExecutor提供了更强大的任务取消和重新调度功能，可以更方便地管理任务的执行。
			6. 资源利用：
				Timer：由于只有一个线程，如果任务执行时间过长或频繁，可能会浪费系统资源。
				ScheduledThreadPoolExecutor：通过线程池管理，ScheduledThreadPoolExecutor可以更好地利用系统资源，避免资源的浪费。
			总的来说，ScheduledThreadPoolExecutor在功能、灵活性、异常处理以及资源利用等方面都优于Timer。因此，在大多数情况下，推荐使用ScheduledThreadPoolExecutor来执行定时或周期性任务。
			7. ScheduledThreadPoolExecutor 在 Java 中提供了任务取消和重新调度的功能，这使得它在处理复杂的定时任务场景时具有更高的灵活性和可控性。
			提交任务时可以得到一个ScheduledFutrue
				任务取消:
			在 ScheduledThreadPoolExecutor 中，你可以通过返回的 ScheduledFuture 对象来取消定时任务。
			ScheduledFuture 是 Future 和 ScheduledFuture 接口的实现，它表示一个异步计算的结果。它提供了 cancel(boolean mayInterruptIfRunning) 方法来取消任务的执行。
					cancel(true): 正在执行的任务将被中断
					cancel(false): 不会中断正在执行的任务，只是取消尚未开始执行的任务
				重新调度: 
			先取消, 再重新提交一个新的任务
		小结:
			ScheduledThreadPoolExecutor是一个定时任务的线程池，它的主要作用是周期性的执行任务。
			它的实现原理是通过DelayedWorkQueue来保存等待的任务，DelayedWorkQueue是一个无界优先队列，使用数组存储，底层使用堆结构来实现优先队列的功能。
28. 原子操作类Atomic/Java atomic包中的原子操作类（AtomicInteger）总结
			volatile < Atomic < Sychronized
		1. Java 中的原子操作类，如 AtomicInteger 和 AtomicLong，底层就是利用 CAS 来确保变量更新的原子性的。
		2. Unsafe 类是 Java 中的一个特殊类，用于执行低级、不安全的操作。
			Unsafe类: 它在sun.misc包中。它里面都是一些native方法，其中就有几个是关于 CAS. 
		3. CAS 是一种常用的无锁技术，允许在多线程环境中原子地更新值。
			CAS 是一种原子操作，它是一种系统原语，是一条 CPU 的原子指令，从 CPU 层面已经保证它的原子性。
		小结:
			Java 中的 java.util.concurrent.atomic 包提供了一系列类，这些类支持原子操作（即线程安全而无需同步）在单个变量上，这大大减少了并发编程的复杂性。
			原子操作类主要有这些：
			1. 原子操作的基本数据类型：AtomicBoolean、AtomicInteger、AtomicLong；
			2. 原子操作的数组类型：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray；
			3. 原子操作的引用类型：AtomicReference、AtomicReferenceFieldUpdater、AtomicMarkableReference；
29. 魔法类Unsafe
		1. 只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，这是为了防止这些方法在不可信的代码中被调用。Unsafe 类中的很多基础方法都属于native方法.
			//native 关键字告诉 JVM 调用的是该方法在外部定义
			native 关键字在 JDK 源码中很多类中都有，在 Object.java类中，其 getClass() 方法、hashCode()方法、clone() 方法等等都是用 native 关键字修饰的。
		2. Unsafe 应用
			1) 内存操作
				//分配新的本地空间
				 public native long allocateMemory(long bytes);
				 //重新调整内存空间的大小
				 public native long reallocateMemory(long address, long bytes);
				 //将内存设置为指定值
				 public native void setMemory(Object o, long offset, long bytes, byte value);
				 //内存拷贝
				 public native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes);
				 //清除内存
				 public native void freeMemory(long address);
			2) 内存屏障
				了解 Java 内存模型（JMM）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中变量的，
				只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。
				在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。
				而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（Memory Barrier）就是通过组织屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。
				在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。
				在 Java8 中，引入了 3 个内存屏障的方法，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 jvm 来生成内存屏障指令，来实现内存屏障的功能。Unsafe 中提供了下面三个内存屏障相关方法：
				//禁止读操作重排序
				public native void loadFence();
				 //禁止写操作重排序
				 public native void storeFence();
				 //禁止读、写操作重排序
				 public native void fullFence();
				内存屏障可以看做对内存随机访问操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。
				以loadFence方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。
				看到这估计很多小伙伴们会想到 volatile 关键字了，如果在字段上添加了volatile关键字，就能够实现字段在多线程下的可见性。
				基于读内存屏障，我们也能实现相同的功能。
			3) 对象操作
				01、对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。
						除了前面的putInt、getInt方法外，Unsafe 提供了 8 种基础数据类型以及Object的put和get方法，并且所有的put方法都可以越过访问权限，直接修改内存中的数据。
				02、使用 Unsafe 的allocateInstance方法，允许我们使用非常规的方式进行对象的实例化，
				通过allocateInstance方法创建对象过程中，不会调用类的构造方法。
				使用这种方式创建对象时，只用到了Class对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。
				在上面的例子中，如果将 A 类的构造方法改为private类型，将无法通过构造方法和反射创建对象，但allocateInstance方法仍然有效。
				反射创建对象
					public void setAccessible(boolean flag)  
					将值 设为true,压制(或者叫取消)java语言访问检查。此时我们就可以使用私有的构造方法来创建对象了
			4) 数组操作
				在 Unsafe 中，可以使用arrayBaseOffset方法获取数组中第一个元素的偏移地址，使用arrayIndexScale方法可以获取数组中元素间的偏移地址增量
			5) CAS操作
				nsafe 类中，提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作。
				
			6) 线程调度
				1. Unsafe 类中提供了park、unpark、monitorEnter、monitorExit、tryMonitorEnter方法进行线程调度
				2. LockSupport 的park方法调用了 Unsafe 的park方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用unpark方法唤醒当前线程。
			7) Class操作
				Unsafe 对Class的相关操作主要包括类加载和静态变量的操作方法。
			8) 系统信息
				Unsafe 中提供的addressSize和pageSize方法用于获取系统信息，调用addressSize方法会返回系统指针的大小，如果在 64 位系统下默认会返回 8，而 32 位系统则会返回 4。
				调用 pageSize 方法会返回内存页的大小，值为 2 的整数幂。
	********************
				CAS（Compare-and-Swap）操作在Java中是一种重要的原子操作，主要用于实现无锁数据结构，提高并发性能。Java在多个地方用到了CAS操作，以下是一些典型的例子：
				1. java.util.concurrent.atomic包：
					这个包提供了大量的原子变量类，如AtomicInteger、AtomicLong、AtomicBoolean、AtomicReference等。这些原子变量类内部都使用了CAS操作来确保线程安全地更新变量的值。
				2. java.util.concurrent.locks包：
					这个包中的ReentrantLock类在内部实现中使用了CAS操作来尝试获取锁。当锁未被占用时，通过CAS操作将锁的持有者设置为当前线程，从而实现快速获取锁。
				3. ConcurrentHashMap：
					Java中的ConcurrentHashMap是一个线程安全的哈希表实现，它使用了分段锁和CAS操作来确保并发访问时的性能。在更新节点值时，ConcurrentHashMap会使用CAS操作来尝试更新节点的值，以避免不必要的锁竞争。
				4. LongAdder和LongAccumulator：
					这两个类也是Java 8中引入的用于高性能并发计算的类。它们内部使用了CAS操作和分段计数的方式来减少多线程更新长整型变量时的锁竞争，从而提高性能。
				5. StampedLock：
				StampedLock是Java 8中引入的一个新的锁实现，它提供了乐观读、悲观读和写锁三种模式。在乐观读模式下，StampedLock使用CAS操作来检查锁的状态，从而实现无锁读取。
				6. 自定义无锁数据结构：
					除了Java标准库提供的类外，开发者在自定义无锁数据结构（如无锁队列、无锁栈等）时，也会广泛使用CAS操作来确保线程安全地更新数据结构的状态。
					CAS操作虽然能够提高并发性能，但也存在一些问题，如ABA问题（一个值原来是A，后来被线程一改成B，又被线程二改成A，那么CAS检查时发现值仍然为A，误以为没有被修改过）、自旋时间过长导致CPU资源浪费等。
					因此，在使用CAS操作时，需要权衡其优点和缺点，并根据具体场景选择合适的并发控制策略。
		总结
			在本文中，我们首先介绍了 Unsafe 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。
			相信大家通过这一过程，能够发现 Unsafe 在某些场景下，确实能够为我们提供编程便利。
			但在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。
			尽管之前有传言说会在 Java9 中移除 Unsafe 类，不过它还是照样已经存活到了 JDK 16，
			按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 Unsafe 的过程中一定要做到使用谨慎使用、避免滥用。
30. 通信工具类/Java并发编程通信工具类 Semaphore、Exchanger、CountDownLatch、CyclicBarrier、Phaser等一网打尽
		1. Semaphore/信号量-控制同时访问的线程个数/AQS
			acquire()方法会申请一个 permit，而 release 方法会释放一个 permit。
			当然，你也可以申请多个 acquire(int permits)或者释放多个 release(int permits)。
			每次 acquire，permits 就会减少一个或者多个。如果减少到了 0，再有其他线程来 acquire，那就要阻塞这个线程直到有其它线程 release permit 为止。
				原理
			Semaphore 内部有一个继承了 AQS 的同步器 Sync，重写了tryAcquireShared方法。在这个方法里，会去尝试获取资源。
			如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入 AQS 的等待队列。
		2. Exchanger/两个线程交换数据/CAS
			Exchanger 类用于两个线程交换数据。它支持泛型，也就是说你可以在两个线程之间传送任何数据。
				原理
			当一个线程调用 exchange 方法后，会处于阻塞状态，只有当另一个线程也调用了 exchange 方法，它才会继续执行。
		3. CountDowmLatch/倒计数锁存器/AQS
			CountDown 代表计数递减，Latch 是“门闩”的意思。也有人把它称为“屏障”。
			而 CountDownLatch 这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。
				原理
			其实 CountDownLatch 类的原理挺简单的，内部同样是一个继承了 AQS 的实现类 Sync，且实现起来还很简单，可能是 JDK 里面 AQS 的子类中最简单的实现了，有兴趣的小伙伴可以去看看这个内部类的源码。
			需要注意的是构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且 CountDownLatch没有提供任何机制去重新设置这个计数值。
		4. CyclicBarrier/回环栅栏-等待至barrier状态再全部同时执行/Lock, Condition
			CyclicBarrirer 从名字上来理解是“循环屏障”的意思。前面提到了 CountDownLatch 一旦计数值count被降为 0 后，就不能再重新设置了，它只能起一次“屏障”的作用。
			而 CyclicBarrier 拥有 CountDownLatch 的所有功能，还可以使用reset()方法重置屏障。
				原理
			CyclicBarrier 虽说功能与 CountDownLatch 类似，但是实现原理却完全不同，CyclicBarrier 内部使用的是 Lock + Condition 实现的等待/通知模式。
		5. Phaser/ 阶段协同器/Fork-Join框架
			Phaser 是 Java 7 中引入的一个并发同步工具，它提供了对动态数量的线程的同步能力，
			这与 CyclicBarrier 和 CountDownLatch 不同，因为它们都需要预先知道等待的线程数量。Phaser 是多阶段的，意味着它可以同步不同阶段的多个操作。
			
			总结
		总的来说，CountDownLatch，CyclicBarrier，Phaser 是一个比一个强大，但也一个比一个复杂，需要根据自己的业务需求合理选择。
31. Fork-Join框架
		1. 分治任务模型
			分治任务模型可分为两个阶段：
													一个阶段是 任务分解，就是迭代地将任务分解为子任务，直到子任务可以直接计算出结果；
													另一个阶段是 结果合并，即逐层合并子任务的执行结果，直到获得最终结果。
		2. 小结
			Fork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。
			这个过程非常类似于大数据处理中的 MapReduce，所以你可以把 Fork/Join 看作单机版的 MapReduce。
			Fork/Join 并行计算框架的核心组件是 ForkJoinPool。ForkJoinPool 支持任务窃取机制，能够让所有线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。
			Java 1.8 提供的 Stream API 里面并行流也是以 ForkJoinPool 为基础的。不过需要注意的是，默认情况下所有的并行流计算都共享一个 ForkJoinPool，这个共享的 ForkJoinPool 默认的线程数是 CPU 的核数；
			如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I/O 密集型的并行流计算，那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能。
			所以 建议用不同的 ForkJoinPool 执行不同类型的计算任务。
32. 生产者-消费者模式
		在实现生产者消费者问题时，可以采用三种方式：
							1. 使用 Object 的 wait/notify 的消息通知机制；
							2. 使用 Lock Condition 的 await/signal 消息通知机制；
							3. 使用 BlockingQueue 实现。
		1. wait/notify 的消息通知机制
			01. wait()
				该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。
				在调用 wait 之前，线程必须获得该对象的监视器锁，即只能在同步方法或同步块中调用 wait 方法。
				调用 wait 方法之后，当前线程会释放锁。如果调用 wait 方法时，线程并未获取到锁的话，
				则会抛出 IllegalMonitorStateException异常。如果再次获取到锁的话，当前线程才能从 wait 方法处成功返回。
			02. notify()
				该方法也需要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁，如果调用 notify 时没有持有适当的锁，也会抛出 IllegalMonitorStateException。
				该方法会从 WAITTING 状态的线程中挑选一个进行通知，使得调用 wait 方法的线程从等待队列移入到同步队列中，
				等待机会再一次获取到锁，从而使得调用 wait 方法的线程能够从 wait 方法处退出。
				调用 notify 后，当前线程不会马上释放该对象锁，要等到程序退出同步块后，当前线程才会释放锁。

			03. notifyAll()
				该方法与 notify 方法的工作方式相同，重要的一点差异是：notifyAll 会使所有原来在该对象上 wait 线程统统退出 WAITTING 状态，
				使得他们全部从等待队列中移入到同步队列中去，等待下一次获取到对象监视器锁的机会。
				不过，wait/notify 消息通知存在这样一些问题。
					1. notify 过早通知
						针对这种问题的解决方法是，添加一个状态标志，让 waitThread 调用 wait 方法前先判断状态是否已经改变了，如果通知已经发出，WaitThread 就不再去 wait。
					2. 等待 wait 的条件发生变化
					3. “假死”状态
						现象：如果是多消费者和多生产者情况，使用 notify 方法可能会出现“假死”的情况，即所有的线程都处于等待状态，无法被唤醒。
						原因分析：假设当前有多个生产者线程调用了 wait 方法阻塞等待，其中一个生产者线程获取到对象锁之后使用 notify 通知处于 WAITTING 状态的线程，
						如果唤醒的仍然是生产者线程，就会造成所有的生产者线程都处于等待状态。
						解决办法：将 notify 方法替换成 notifyAll 方法，如果使用的是 lock 的话，就将 signal 方法替换成 signalAll 方法。
						总结：Object 提供的消息通知机制应该遵循如下这些条件：
						永远在 while 循环中对条件进行判断而不是在 if 语句中进行 wait 条件的判断；
						使用 NotifyAll 而不是使用 notify。
						基本的使用范式如下：
							// The standard idiom for calling the wait method in Java
							synchronized (sharedObject) {
								while (condition) {
								sharedObject.wait();
									// (Releases lock, and reacquires on wakeup)
								}
								// do action based upon condition e.g. take or put into queue
							}
	1. wait/notifyAll 实现生产者-消费者
	2. await/signalAll 实现生产者-消费者
	3. BlockingQueue 实现生产者-消费者
		生产者-消费者应用场景
	生产者-消费者模式一般用于将生产数据的一方和消费数据的一方分割开来，将生产数据与消费数据的过程解耦开来。

		#01、Excutor 任务执行框架：
		通过将任务的提交和任务的执行解耦开来，提交任务的操作相当于生产者，执行任务的操作相当于消费者。
		例如使用 Excutor 构建 Web 服务器，用于处理线程的请求：生产者将任务提交给线程池，线程池创建线程处理任务，
		如果需要运行的任务数大于线程池的基本线程数，那么就把任务扔到阻塞队列
		（通过线程池+阻塞队列的方式比只使用一个阻塞队列的效率高很多，因为消费者能够处理就直接处理掉了，不用每个消费者都要先从阻塞队列中取出任务再执行）
		#02、消息中间件 MQ:
		双十一的时候，会产生大量的订单，那么不可能同时处理那么多的订单，需要将订单放入一个队列里面，然后由专门的线程处理订单。
		这里用户下单就是生产者，处理订单的线程就是消费者；再比如 12306 的抢票功能，先由一个容器存储用户提交的订单，然后再由专门处理订单的线程慢慢处理，这样可以在短时间内支持高并发服务。
		#03、任务的处理时间比较长的情况下：
		比如上传附件并处理，那么这个时候可以将用户上传和处理附件分成两个过程，用一个队列暂时存储用户上传的附件，然后立刻返回用户上传成功，然后有专门的线程处理队列中的附件。
		生产者-消费者模式的优点：
		解耦：将生产者类和消费者类进行解耦，消除代码之间的依赖性，简化工作负载的管理
		复用：通过将生产者类和消费者类独立开来，对生产者类和消费者类进行独立的复用与扩展
		调整并发数：由于生产者和消费者的处理速度是不一样的，可以调整并发数，给予慢的一方多的并发数，来提高任务的处理速度
		异步：对于生产者和消费者来说能够各司其职，生产者只需要关心缓冲区是否还有数据，不需要等待消费者处理完；
		对于消费者来说，也只需要关注缓冲区的内容，不需要关注生产者，通过异步的方式支持高并发，将一个耗时的流程拆成生产和消费两个阶段，
		这样生产者因为执行 put 的时间比较短，可以支持高并发
		支持分布式：生产者和消费者通过队列进行通讯，所以不需要运行在同一台机器上，在分布式环境中可以通过 redis 的 list 作为队列，而消费者只需要轮询队列中是否有数据。
		同时还能支持集群的伸缩性，当某台机器宕掉的时候，不会导致整个集群宕掉
		#小结
		本文主要讲解了线程的等待/通知机制，包括 wait/notify/notifyAll 方法的使用，以及使用 wait/notifyAll 实现生产者-消费者模型的示例代码。
		还有 Condition 的 await/signalAll 方法的使用，以及使用 Condition 的 await/signalAll 实现生产者-消费者模型的示例代码。最后还讲解了使用 BlockingQueue 实现生产者-消费者模型的示例代码。
***************
	CAS: 
			1. Java的java.util.concurrent.atomic包中的原子类（如AtomicInteger、AtomicLong等）
			2. ConcurrentHashMap, CopyOnWriteArrayList, ConcurrentLinkedQueue
			3. Exchanger
	AQS:
			1. ReentrantLock、Semaphore、CountDownLatch
			供的几个核心方法（如tryAcquire、tryRelease等）
***********************************************************************************************
***********************************************************************************************
十二、JVM
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
***************************************************************************************************************



************************************************************************************************************************************************************************************************************
面试指南
************************************************************************************************************************************************************************************************************
面试官您好，感谢您给我这次面试的机会。
	我是一位经验丰富的Java开发者，具备扎实的编程基础和良好的解决问题的能力。
	我熟悉Java核心语法，对面向对象编程有深入的理解，并且熟练掌握了Java集合框架、多线程编程、异常处理等方面的知识。

	在过往的项目中，我负责过多个模块的开发工作，包括后端业务逻辑的实现、数据库交互、API接口设计等。
	我能够熟练使用Spring Boot、Spring MVC、MyBatis等框架进行开发，并且熟悉Maven、Git等开发工具的使用。
	此外，我也具备良好的团队合作和沟通能力，能够与产品经理、前端开发者等成员进行有效的协作。

	针对您公司的具体业务需求，我相信我能够快速融入团队并贡献自己的力量。我期待能够在贵公司发挥我的专业技能，并与团队成员共同创造更大的价值。谢谢！
	
一、8种基本数据类型
二、常见的数据结构
三、Java的集合框架/Java集合框架是基本数据结构在Java语言中的实现和描述。
四、Java IO	
五、异常处理
六、常用工具类
七、Java新特性(流Stream/Optional/Lambda)
八、网络编程
九、Java NIO
十、Java重要知识点
十一、并发编程
十二、JVM
		1) JMM内存模型, 栈、方法区存放的是什么.
			答: JMM内存模型定义了线程与主内存之间的抽象关系:
						线程之间的共享变量存储在主内存中
						每个线程都有一个本地内存
						本地内存中存储了该线程读写共享变量的副本
		2) java的类加载机制, 双亲委派机制, 这样设计的原因是什么
			答: 
		
*****其他知识点#######################################################################################################################################################################

*******************************************
一. Java
1.  标识符与关键字
		 标识符是用于给变量、类、方法、接口等命名的一种符号. 
		 要求:
		 1) 第一个字符不能是数字
		 2) 由数字、字母、下划线、美元符号组成
		 3) 标识符不能是关键字
		 4) 标识符不能是true、false、null
		 
		 java的50个关键字:
		 abstract 、assert 、boolean、break、byte、case、catch、char、class、const、continue、
		 default 、do、double、else、enum、extends、final、finally、float、for、goto、if、
		 implements、import、instanceof、int、interface、long、native、new、package、
		 private、protected、public、return、short 、static、strictfp、super、switch、synchronized、
		 this 、throw、throws、transient 、try 、void、volatile、while
1) abstract
		 在Java中，abstract是一个关键字，它用于声明抽象类或抽象方法。抽象类是一种不能被实例化的类，
		 它通常包含一些抽象方法，这些方法在抽象类中没有具体的实现。抽象类的主要目的是作为其他类的基类，
		 提供通用的属性和行为，同时允许子类根据需要实现特定的细节。
		 抽象方法只能声明在抽象类中.
2) assert
		 assert是一个关键字，用于进行断言。断言是一种调试工具，它允许程序员在代码中设置检查点，
		 以确保程序在运行时满足某些条件。如果条件为真（即断言成功），则程序将继续正常执行。
		 如果条件为假（即断言失败），则程序将抛出一个AssertionError异常。
		 在默认情况下，断言是禁用的。要启用断言，你需要在启动Java虚拟机（JVM）时通过命令行选项-enableassertions或-ea来启用它们
		 启用断言后，JVM会检查所有的assert语句。如果条件为假，它将抛出一个AssertionError异常，并显示你提供的错误消息（如果有的话）。
		 断言通常用于验证程序的状态或输入参数的有效性。它们不应该用于处理正常的程序逻辑，因为断言在默认情况下是禁用的，
		 并且在生产环境中通常不启用断言。断言主要用于开发和测试阶段，以帮助程序员发现和修复代码中的错误。
		 3) intanceof
		 判断对象是否符合指定的类型
		 instanceof关键字的作用是判断左边对象是否是右边类(这里有很多人说是对象，所以注意这里是类，并不是对象)的实例
		 (通俗易懂的说就是：子类对象，或者右边类本身的对象)返回的boolean类型，true和false。
		 if(o instanceof Yuan){//判断是否为圆的对象，不是则往下执行判断else if
				System.out.println("圆的面积为：" + ((Yuan)o).mianJi);//这里(Yuan)Object)防止参数o是Yuan的子类，此方法获得面积。
			System.out.println("圆的直径为：" + ((Yuan)o).zhiJing);//此方法获得直径。
			}else if（o instanceof ChangFangXing）{
				System.out.println("长方形的面积为：" + ((ChangFangXing)o));
			}
3) const
	const是java中的预留关键字（java中预留关键字还有goto）, 在C或C++中，const关键字用于声明一个变量的值为常量，即该变量的值在初始化后不能被修改。
4) final
		Java关键字,修饰符, 修饰变量, 变量不可变, 修饰方法, 方法不能被重写, 修饰类, 类不能被继承
4) instanceof
	判断对象是否符合指定的类型，
	结果要么是 true，要么是 false。
	在反序列化的时候，instanceof 操作符还是蛮常用的，因为这时候我们不太确定对象属不属于指定的类型，如果不进行判断的话，就容易抛出 ClassCastException 异常。
5) native
		//native 关键字告诉 JVM 调用的是该方法在外部定义
			native 关键字在 JDK 源码中很多类中都有，在 Object.java类中，其 getClass() 方法、hashCode()方法、clone() 方法等等都是用 native 关键字修饰的。
			它用于声明一个方法是原生的（native method）。一个原生方法是使用其他语言（如C、C++或汇编语言）编写的，
			并且被编译为机器代码，而不是Java字节码。然后，这个机器代码可以通过Java的本地接口（JNI，Java Native Interface）在Java程序中调用。
			 1)) 访问底层系统资源：Java是一种跨平台的语言，设计初衷是为了避免直接与底层硬件和操作系统进行交互。
			 然而，有时候为了性能考虑或者访问特定的系统资源，Java程序可能需要直接调用底层代码。

			2)) 性能优化：某些计算密集型任务可能使用原生代码（如C或C++）比使用Java代码执行得更快。

			3)) 利用现有的库：如果已经有现成的用其他语言编写的库或API，可以使用原生方法来调用这些库。

			4)) 遗留代码的集成：在集成遗留代码（legacy code）时，可能需要使用原生方法来调用这些已经用其他语言编写的代码。
			    // 声明一个原生方法  
			public native void myNativeMethod();  
  
				// 加载包含原生方法实现的库  
			static {  
				System.loadLibrary("NativeDemoLib");  
			}  
			原生方法的使用应该谨慎，因为它们破坏了Java的跨平台性，并且增加了代码的复杂性。在大多数情况下，应该优先考虑使用纯Java的解决方案。
6) static
	方便在没有创建对象的情况下进行调用，包括变量和方法
7) strictfp
			它用于声明一个方法或类，以确保在该方法或类中执行的浮点数运算遵循 IEEE 754 单精度或双精度浮点算术标准。IEEE 754 是定义浮点数表示和运算的标准。
			当你在一个方法或类上使用 strictfp 关键字时，该方法或类中的所有浮点运算（如加法、减法、乘法、除法和比较）都将按照 IEEE 754 标准进行。
			这确保了无论 Java 虚拟机（JVM）如何优化这些运算，结果都将是确定的，且与其他遵循相同标准的平台一致。
			strictfp 主要用于那些需要精确浮点运算的场景，例如金融计算，其中精确到小数点后几位是非常重要的。
			需要注意的是，strictfp 关键字并不能保证所有的浮点运算结果都是精确的，因为浮点数的表示本身就存在精度问题
			（例如，不是所有的十进制小数都能精确地用二进制浮点数表示）。然而，它确实确保了跨平台和跨 JVM 的浮点运算结果的一致性。
8) this & super : 
				this是Java关键字, 可以指向当前对象, 调用方法, 作为参数或返回值
				super是Java关键字, 可以指向父类, 调用父类方法
9) synchronized
		关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，
		同时我们还应该注意到 synchronized 的另外一个重要的作用，synchronized 可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代 volatile 功能）。
10) throw和throws
			throw 用于在方法内部抛出异常对象。
			throws 用于在方法签名中声明方法可能抛出的异常类型。
11) transient(暂时的)
			在实际开发过程中，我们常常会遇到这样的问题，一个类的有些字段需要序列化，有些字段不需要，
			比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。

			需要注意的是，被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值，例如基本数据类型为 0，引用类型为 null。
12) volatile
		volatile 可以保证变量可见性，但不保证原子性：
		当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；
		这个写操作会导致其他线程中的 volatile 变量缓存无效。
		volatile关键字可以修饰在类变量或者实例变量上，不能修饰在方法参数，局部变量，实例常量以及类常量上。
********
		synchronized和volatile都是Java中用于实现多线程同步的机制，但它们之间存在一些重要的区别。
		同步机制：
		synchronized：它利用锁来保证同步，当一个线程进入一个对象的synchronized方法或代码块时，其他线程对该对象的所有synchronized方法或代码块的访问将被阻塞，直到第一个线程退出synchronized方法或代码块。
		这确保了同一时刻只有一个线程可以执行某个synchronized方法或代码块。
		volatile：它利用内存屏障来保证可见性和禁止指令重排。当一个变量被声明为volatile时，它确保所有线程都能看到该变量的最新值，即当一个线程修改了这个变量的值，新值对其他线程立即变得可见。
		但volatile不保证原子性，也就是说，它不能保证复合操作的完整性。
		内存开销：
		synchronized：它在使用时有一定的内存开销，因为需要进行锁的申请、释放、等待等操作。这些操作涉及到线程间的通信和协作，因此会带来一定的性能损耗。
		volatile：它没有锁的开销，通过CPU的缓存一致性实现了数据的可见性。它通常比synchronized具有更小的性能开销。
		线程安全：
		synchronized：它是线程安全的，因为它通过锁机制确保了同一时刻只有一个线程可以访问共享资源，从而保证了多线程下数据的准确性。
		volatile：它本身并不保证线程安全。它只是保证了变量的可见性，但并不能保证复合操作的原子性。对于需要原子性保证的操作，如自增、自减等，volatile是不够的，需要结合其他同步机制（如synchronized或AtomicInteger）来实现线程安全。
		使用场景：
		synchronized：适用于需要保证整个方法或代码块的原子性和可见性的情况，或者需要防止多个线程同时访问共享资源的情况。
		volatile：适用于只需要保证单个变量的可见性，且该变量的操作是简单的读写操作，不需要保证原子性的情况。
		总结来说，synchronized和volatile在Java中各有其用途，选择使用哪一个取决于具体的场景和需求。对于需要保证整个方法或代码块的原子性和可见性的情况，通常使用synchronized；而对于只需要保证单个变量的可见性，且操作简单的情况，可以使用volatile。
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
2. 基本数据类型转换
	int = short + short (JVM最小指令集运算为 int)
	为较小的类型引入专用的算术逻辑单元不值得付出努力：
	它需要额外的晶体管，但它仍然只能在一个时钟周期内执行一次加法。 JVM设计时的主流架构是32位，适合32位int。

----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
3. System.exit(status)不管status为何值都会退出程序。
	return是回到上一层，而System.exit(status)是回到最上层
	System.exit(0)是正常退出程序，而System.exit(1)或者说非0表示非正常退出程序
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
4. Java序列化
	1. 什么是Java序列化？
	Java序列化是指将Java对象转换为字节流的过程，以便可以将这些字节流保存到磁盘、发送到其他网络节点或用于其他目的。

	2. 为什么需要Java序列化？
	Java序列化主要用于对象的持久化，例如将对象保存到文件中或数据库中。
	它也用于在网络中传输对象，例如在远程方法调用（RMI）或分布式系统中。
	3. 如何实现Java序列化？
	要使一个类可序列化，必须实现java.io.Serializable接口。这是一个标记接口，没有定义任何方法。
	类的所有属性必须是可序列化的，如果属性不可序列化，则它们必须被标记为transient。
	4. transient关键字在Java序列化中起什么作用？
	transient关键字用于指示某个属性不应被序列化。它通常用于那些不能或不应被序列化的属性，例如线程、网络连接、文件句柄等。
	5. Java序列化有哪些版本控制机制？
	Java序列化提供了一种版本控制机制，通过serialVersionUID字段来实现。这是一个私有的、静态的、最终的long类型字段。
	当类的定义更改时，serialVersionUID也应该更改，以指示序列化和反序列化过程应验证类的版本兼容性。
	6. 什么是序列化ID (serialVersionUID)，它在Java序列化中起什么作用？
	serialVersionUID是一个唯一的版本号，用于标识类的不同版本。
	当类的定义发生更改时，serialVersionUID应该更改，以确保反序列化时对象与类的当前定义匹配。
	7. Java序列化和反序列化的过程是什么？
	序列化：将对象转换为字节流的过程。使用ObjectOutputStream类的writeObject()方法。
	反序列化：将字节流转换回对象的过程。使用ObjectInputStream类的readObject()方法。
	8. Java序列化有哪些限制？
	静态变量不会被序列化。
	瞬态变量（transient标记的变量）不会被序列化。
	序列化机制对于安全性有潜在的风险，因为它允许将任何对象转换为字节流，并可能在不受信任的环境中执行反序列化。
	9. 如何在Java中自定义序列化过程？
	通过实现writeObject()和readObject()方法来自定义序列化和反序列化过程。这些方法分别在ObjectOutputStream和ObjectInputStream中调用。
	10. Java序列化的安全性问题有哪些？
	反序列化恶意数据可能导致代码执行、拒绝服务攻击等。
	序列化数据可能包含敏感信息，如密码、密钥等。
	使用默认序列化机制可能导致数据泄露。
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
5. Java常见对象分类
	controller接受前端:DTO
	controller返回给前端: VO
	
	dao传给给mybatis: DAO
	dao接受数据库数据: DO(字段必须是包装类型)
	
	数据库的一张表:POJO(字段必须是包装类型)
	数据持久化: PO(一条数据库记录)(字段必须是包装类型)
	controller业务模块: BO(service+dao+util)

	java对象: entity
	
	1. DAO（Data  Access Object）数据访问对象
				一般在业务逻辑层面对数据库的访问是使用，一般只能进行sql操作。
	2. PO（Persistent Object）持久化对象/DO（Domain Object）领域对象
			   ·数据库表中的数据在Java对象中的显示状态，最理想的解释就是PO就是数据库中的一条记录。
				xxxDAO，xxx为实体类名（entity实体类）。
	3. BO（Business Object）业务对象
				一般用在包含业务功能模块的具体实例上。
				比如我写了一个controller，一个service，一个dao，一个util，等等这一系列实例组合后才能实现一些功能，这些一系列实例组合为一个组件，这个组件就是BO。	
	4. DTO（Data Transfer Object）数据传输对象
		RPC Controller
				一般在前端（web）对控制层（controller）进行数据传输时使用，说白了就是前端向后端提交数据。
				xxxDTO，xxx为业务领域相关的名称。
			   另外，DO和Entity概念上浅显相似，它们在实际应用中是一种东西，总的来说，DO是 Entity的一种。
	5.VO（View Object）视图模型
			   一般用在业务逻辑层，对前端的视觉模型效果控制的展示上，说白了就是后端向前端传递数据。
			   xxxVO，xxx为网页名称。
			  自定义的，再封装的，多个表的的属性或字段的集合。
********																						
			   VO与DTO区别【VO：后端给前端；DTO：前端给后端】
	6. DO（Domain Object）领域对象
				DO（ Data Object）这个等同于上面的PO
				另一个是在DDD（Domain-Driven Design）领域驱动设计中
				DO（Domain Object）这个等同于上面的BO										
			   一般在业务逻辑层对数据库的访问时使用接收数据使用。
			   xxxDO，xxx为数据库表名。
			   ·例如我们有一条数据，现在有一个简单类而且是已经被赋予了这条数据的实例，那么这条数据在这个简单类的存在就是PO，不管这个是BO,DO，还是其它，PO只是数据持久化的状态。
			   
	7. Entity（应用程序中的一个概念）实体
				Entity是一个未被持久化的对象，它是一个类，从现实中抽象到代码的一个类。
	8. POJO（Plain Ordinary Java Object）
		普通的Java对象，其实就是简单的JavaBean实体类，对应数据库中的某一张表，POJO 中的每一个属性都应和表中字段一一对应。
6 String.intern()
	用于手动将字符串添加到字符串常量池中。如果常量池中已经包含了一个等于此 String 对象的字符串，则返回常量池中的这个字符串；否则，将此 String 对象添加到常量池中，并返回此 String 对象的引用。
7  .equals() 和 ‘==’ 操作符有什么区别。”
	“==”操作符用于比较两个对象的地址是否相等。
	  .equals() 方法用于比较两个对象的内容是否相等。
8 抽象类和接口
	1) 在Java中，抽象类是一种特殊的类，它不能被实例化，即不能创建抽象类的对象。抽象类的主要作用是作为其他类的基类，为子类提供共同的属性和方法，并要求子类实现某些特定的方法。
	2) 在Java中，接口（Interface）是一种抽象的数据类型，它允许定义一组方法的签名（包括方法名、参数列表和返回类型），但不提供实现细节。
接口中的成员变量隐式为 static final，但抽象类不是的
		语法层面上
	抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；
	抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；
	接口中不能含有静态代码块，而抽象类可以有静态代码块；
	一个类只能继承一个抽象类，而一个类却可以实现多个接口。
		设计层面上
	抽象类对整体: 猫, 狗都是动物, 抽象成动物类
	接口对功能: 猫狗都会跑, 设计一个跑的接口
9 封装, 继承, 多态
	封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。
	继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是复用代码。
	多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。
10  重载和重写
		重载
	提高代码可读性：通过方法重载，我们可以为具有相同名称但参数类型或数量不同的方法提供不同的实现。这使得代码更加清晰易懂，因为开发者可以根据参数类型和数量直观地理解方法的功能。
	灵活性：方法重载允许我们在不改变方法名的情况下，通过改变参数类型和数量来实现不同的功能。这使得代码更加灵活，能够适应不同的使用场景。
	简化调用：在调用方法时，我们可以根据实际需要传递不同的参数类型和数量来调用不同的重载方法。这简化了方法的调用过程，提高了代码的可维护性。
			注意事项
		两同一不同:
			两同：在同一个类，方法名相同。
		一不同：参数不同。
		重写
	多态性：子类通过重写父类的方法，能够定义特定于自己的行为。这种多态性使得子类可以根据需要灵活地实现父类的方法，增强了代码的灵活性和可扩展性。
	完善父类功能：子类通过重写父类的方法，可以完善父类中的不足之处，使自身的方法更加完善。这有助于提升代码的质量和健壮性。
	代码复用：子类通过继承父类并重写其方法，可以复用父类的代码，减少重复编码的工作量。这有助于提高开发效率并降低维护成本。
			注意事项
		两同一小一大:
	两同：方法名相同，参数相同。”
	一小：子类方法声明的异常类型要比父类小一些或者相等。
	一大：子类方法的访问权限应该比父类的更大或者相等。
11 注解
	注解（Annotation）是在 Java 1.5 时引入的概念，同 class 和 interface 一样，也属于一种类型。
	注解提供了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作。
12 枚举
	枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。
	枚举默认实现了 Serializable 接口
13 线程按顺序执行9种方法
			1. Thread类的方法join()
			2. Object类的方法wait(), notify(), notifyAll()
					这些方法与synchornized关键字相配合,可以实现等待/通知模式
			3. JUC包下
				Condition对象是由Lock对象(调用Lock对象的newCondition()方法)创建出来的
				Condition是个接口,基本的方法就是await()和signal()方法;
				Condition依赖于Lock接口,生成一个Condition的基本代码是lock.newCondition()
				与Lock配合可以实现等待/通知模式
				LockSupport 是一组基于底层 Unsafe 本地方法的公共静态方法
				LockSupport 直接操作线程，而不是通过监视器或锁对象来管理线程的阻塞和唤醒。
				主线程使用park(), unpark()与join类似
			5. CompletableFuture
			6. 并发通信工具类
				Semaphore(信号量)，Exchanger(交换者)，CountDownLatch(倒计数锁存器)，CyclicBarrier(回环栅栏)，Phaser(阶段协同器)
			7. 线程池ExecutorService, ThreadPoolExecutor
		1) 在子线程中通过join()方法指定顺序
			join():是Theard的方法，作用是调用线程需等待该join()线程执行完成后，才能继续用下运行。
			应用场景：当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。
		2) 在主线程中通过join()方法指定顺序
			 这里是在主线程中使用join()来实现对线程的阻塞。
		3) 使用线程的wait方法
			wait():是Object的方法，作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)
			notify()和notifyAll():是Object的方法，作用则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。
			wait(long timeout):让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的notify()方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。
			应用场景：Java实现生产者消费者的方式。
		4) 使用线程的线程池方法
			 JAVA通过Executors提供了四种线程池
				1. 单线程化线程池(newSingleThreadExecutor);
				2. 可控最大并发数线程池(newFixedThreadPool);
				3. 可回收缓存线程池(newCachedThreadPool);
				4. 支持定时与周期性任务的线程池(newScheduledThreadPool)。
			单线程化线程池(newSingleThreadExecutor):优点，串行执行所有任务。
			submit()：提交任务。
			shutdown()：方法用来关闭线程池，拒绝新任务。
			应用场景:串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
		5) 使用线程的Condition(条件变量)方法
			Condition  [kənˈdɪʃn]（条件变量）:通常与一个锁关联。需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。
				1. Condition中await()方法类似于Object类中的wait()方法。
				2. Condition中await(long time,TimeUnit unit)方法类似于Object类中的wait(long time)方法。
				3. Condition中signal()方法类似于Object类中的notify()方法。
				4. Condition中signalAll()方法类似于Object类中的notifyAll()方法。
			应用场景：Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被带调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。
		6) 使用线程的CountDownLatch（倒计数）方法
			CountDownLatch  [kaʊnt  daʊn  lætʃ] :位于java.util.concurrent包下，利用它可以实现类似计数器的功能。
			应用场景:比如有一个任务C，它要等待其他任务A,B执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。	
			await() 方法会使当前线程等待，直到计数器达到零。
		7) 使用CyclicBarrier(回环栅栏)实现线程按顺序运行
			 CyclicBarrier(回环栅栏)  [ˈsaɪklɪk   ˈbæriə(r)] :通过它可以实现让一组线程等待至某个状态之后再全部同时执行。
			 叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。
			应用场景:公司组织春游,等待所有的员工到达集合地点才能出发，每个人到达后进入barrier状态。都到达后，唤起大家一起出发去旅行。
		8) 使用Sephmore(信号量)实现线程按顺序运行
			Sephmore(信号量) [ˈseməfɔː(r)] :Semaphore是一个计数信号量,从概念上将，Semaphore包含一组许可证,如果有需要的话，每个acquire()方法都会阻塞，
			直到获取一个可用的许可证,每个release()方法都会释放持有许可证的线程，并且归还Semaphore一个可用的许可证。然而，实际上并没有真实的许可证对象供线程使用，Semaphore只是对可用的数量进行管理维护。
			acquire()   [əˈkwaɪə(r)] :当前线程尝试去阻塞的获取1个许可证,此过程是阻塞的,当前线程获取了1个可用的许可证，则会停止等待，继续执行。
			release()   [rɪˈliːs] :当前线程释放1个可用的许可证。
			应用场景:Semaphore可以用来做流量分流，特别是对公共资源有限的场景，比如数据库连接。假设有这个的需求，读取几万个文件的数据到数据库中，
			由于文件读取是IO密集型任务，可以启动几十个线程并发读取，但是数据库连接数只有10个，这时就必须控制最多只有10个线程能够拿到数据库连接进行操作。这个时候，就可以使用Semaphore做流量控制。
		9). CompletableFuture 
			CompletableFuture是对Future的扩展和增强。CompletableFuture实现了Future接口，并在此基础上进行了丰富的扩展，完美弥补了Future的局限性，同时CompletableFuture实现了对任务编排的能力。
			使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。
			从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。
			当任务执行完之后，会通知调用线程来执行回调方法。而在调用回调方法之前，调用线程可以执行其他任务，是非阻塞的。
			CompletableFuture还提供了串行、AND聚合、OR聚合调用多个任务，以及支持异常处理。
			CompletableFuture提供了四个静态方法来创建一个异步操作：
				public static CompletableFuture<Void> runAsync(Runnable runnable)
				public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
				public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
				public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
				
				1. 是否有返回值: runAsync, supplyAsync
				2. join()和get()方法都是用来获取CompletableFuture异步之后的返回值
					join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者强制捕捉，
					会将异常包装成CompletionException异常 /CancellationException异常，但是本质原因还是代码内存在的真正的异常
					get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理/铺抓（抛出或者 try catch）
				3.  thenRun(Runnable action): 沿用上一个任务的线程池
				     thenRunAsync(Runnable action): 使用公用的 ForkJoinPool 线程池(不推荐使用公用线程池)
				     thenRunAsync(Runnable action,Executor executor): 使用自定义线程池(推荐)

14. Java修饰符分为：1.访问修饰符    2.非访问修饰符
		用来修饰类、方法或变量。

	1.访问修饰符：
		有public、default、protected、private四种

		public：任何其他类可见。
		protected：包内可见，包外继承子类可见。 不能修饰类(内部类除外)。接口以及接口的成员变量和方法都不能声明为protrcted。
		default：包内可见，包外不可见。接口里的变量都隐式声明为 public static final，而方法默认为public。	
		private：包内同类可见。
		 访问控制和继承

		父类中声明为public的方法，在子类也必须声明为public
		父类中声明为protected的方法，在子类中只能声明为public或protected， 不能声明为private。
		父类中声明为private的方法，不能被继承。
		
		接口类: 只有public
		抽象类: 默认的权限修饰符为 public，可以定义为 public 或 procted，如果定义为 private，那么子类则无法继承。
		
		接口方法的访问修饰符:  public abstract
		抽象类方法的访问修饰符: private, default, protect, public,
		
		接口变量:接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误），必须赋初值，不能被修改
		抽象变量: private, default, protect, public,
		
	2.非访问修饰符/不用于控制类、成员变量、方法访问权限的一些特定功能标识符
		有static、final、abstract、synchronize和volatile 五种。

		static：修饰的变量为静态变量，修饰的方法为静态方法。
		静态变量：无论类被实例化多少次，类的静态变量只有一份。局部变量不能声明为静态变量。
		静态方法：静态方法不能调用非静态变量。
		[注：]明白一点，就是静态的属于整个类所有，非静态的属于具体对象所自有，静态方法不能调用非静态变量，因为jvm加载类的时候会初始化静态变量和静态方法，而此时没有百对象的存在，所度以此时会有类似于空指针异常的错误
		final：修饰的类不能被继承；修饰的方法不能被继承重写；修饰的变量为常量，不能改变。
		abstract：修饰的类为抽象类，修饰的方法为抽象方法。
		抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是将来对该类进行扩充；类不能同时被abstract和final修饰；包含抽象方法的类必须声明为抽象类；抽象类可以包含抽象方法和非抽象方法。
		抽象方法：抽象方法没有具体实现功能，具体实现方法由子类完成。
		synchronize：被修饰的方法，同一时间只能被一个线程访问。
		volatile：告诉编译器，被修饰的变量是随时可以变化的，该变量的值的每一次改变，其他使用到的线程都可以立刻知道。
		抽象类和接口的区别：

		抽象类中可以有抽象方法和普通方法，接口中只能有抽象方法
		抽象类中可以有构造方法，接口中没有构造方法
		抽象类中可以有普通变量，接口中只能有public 常量
		抽象类只能单继承类，接口可以继承多个接口(interface xxx extends A,B,C{})
		实现类只能继承一个抽象类，但是可以实现多个接口		
**********
			1.class不加修饰符的时候 即直接声明 class A{ }
				在这种情况下，class前面没有加任何的访问修饰符，通常称为“默认访问模式”，在该模式下，这个类只能被同一个包中的类访问或引用，这一访问特性又称包访问性。
			2.类修饰符：
				(1)public（访问控制符），将一个类声明为公共类，他可以被任何对象访问，一个程序的主类必须是公共类。
				(2)abstract，将一个类声明为抽象类，没有实现的方法，需要子类提供方法实现。
				(3)final，将一个类生命为最终（即非继承类），表示他不能被其他类继承。
			3.成员变量修饰符：
				(1)public（公共访问控制符），指定该变量为公共的，他可以被任何对象的方法访问。
				(2)private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。
				(3)protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。
				(4)friendly ，在同一个包中的类可以访问，其他包中的类不能访问。
				(5)final，最终修饰符，指定此变量的值不能变。
				(6)static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。
				(7**)transient**（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。
				(8)volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改。
			4.方法修饰符：
				(1)public（公共控制符）
				(2)private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）
				(3)protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。
				(4)final，指定该方法不能被重载。
				(5)static，指定不需要实例化就可以激活的一个方法。
				(6)synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。
				(7)native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。
			5. 内部类可为静态，可以用public、protected、private修饰，而外部类只能使用public和缺省的包访问权限
***********
15. 通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？
实现 Runable 接口好，原因有两个：

♠①、避免了 Java 单继承的局限性，Java 不支持多重继承，因此如果我们的类已经继承了另一个类，就不能再继承 Thread 类了。
♠②、适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable 接口与 Runnable 非常相似，但可以返回一个结果。

	4. volatile、synchronied、lock的区别: 
		volatile、synchronized是java关键字, volatile修饰变量, synchronized修饰方法或代码块
		lock是java的一个接口, 在java.util.concurrent.lock包中
		通常通过实现该接口的类 如: ReentrantLock来使用
16 . 算法/algorithm和时间复杂度
	1)时间复杂度计算
		  1. 常数阶
				时间复杂度都是O(1)
		  2.  线性阶, 平方阶
				在for循环里面的所有时间复杂度为O(1)的语句总的时间复杂度都是O(n)
				两个for O(n^2)
		  3.  对数阶
		  我们假设最坏的结果查找了x次，数组有N个数。
			第一次查找：在长度为N的数组中查找值，取中间值进行比较
			第二次查找：在长度为N/2的数组中查找值，取中间值进行比较
			第三次查找：在长度为N/(2^2)的数组中查找值，取中间值进行比较
			所以：N = 2^x
			我们在二边取对数
			longN =x(log2^x)(log是以2为底)。
			既然查找了logN次,也就是说while循环的时间复杂度为O(logN),即该函数的时间复杂度为O(logN)。
		4. 递归->O(2^n)
17  锁分类
		1. 乐观锁CAS
			乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。一旦多个线程发生冲突，乐观锁通常使用一种称为 CAS 的技术来保证线程执行的安全性。
			由于乐观锁假想操作中没有锁的存在，因此不太可能出现死锁的情况，换句话说，乐观锁天生免疫死锁。
			乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；
			悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。
		2. 悲观锁synchronized、vector、hashtable
			对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。
		3. 自旋锁CAS 
			自旋：不断尝试去获取锁，一般用循环来实现。
		4. 可重入锁synchronized、Reentrantlock、Lock
			从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁
		5. 读写锁ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet
		6. 公平锁Reentrantlock(true)
			公平锁是一种思想： 多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，
			如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。
		7. 非公平锁synchronized、reentrantlock(false)
			非公平锁是一种思想： 线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。
			优点： 非公平锁的性能高于公平锁。
			缺点： 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）
			Java中的非公平锁：synchronized是非公平锁，ReentrantLock通过构造函数指定该锁是公平的还是非公平的，默认是非公平的。
		8. 共享锁ReentrantReadWriteLock中读锁
		9. 独占锁synchronized、vector、hashtable、ReentrantReadWriteLock中写锁
		10. 重量级锁synchronized
			重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，
			而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。
		11. 轻量级锁锁优化技术
			多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。
		12. 偏向锁锁优化技术
			JDK 15 之前，偏向锁默认是 enabled，从 JDK 15 开始，默认就是 disabled，除非显示的通过 UseBiasedLocking 开启。
			偏向锁在资源无竞争情况下消除了同步语句，连 CAS（后面会细讲，戳链接直达） 操作都不做了
		13. 分段锁concurrentHashMap
		14. 互斥锁synchronized
		15. 同步锁synchronized
		16. 死锁相互请求对方的资源
		17. 锁粗化锁优化技术
		18. 锁消除锁优化技术
18 正则表达式
	1. +表示1个或多个（如"3"或"225"），*表示0个或多个（[0-9]*）（如""或"1"或"22"），?表示0个或1个([0-9]?)(如""或"7") 
	2. ^ 从开头进行匹配, $ 结束匹配, 如果没有,则匹配整串字符
		toString() 会报空指针异常, String.valueOf返回"null"
		***str.matches匹配的是整个字符串
19. Integer.valueOf()和Integer.parseInt()的区别
		Integer.valueOf()和Integer.parseInt()的返回值类型不同
		基本类型是没有 toString() 方法的, 基本类型转 String 类型时，推荐使用 String.valueOf() 方法。
		包装类型的强转和基本类型的强转一样，都会报错的，这也是各种大佬不使用 (String) 去进行强转的原因
20. <<, <<=, >>, >>=
		1.Java语言中的 << 意思为：逻辑左移，相当于乘2
				如：2<<1、3 << 2、3<<3
				2 << 1，则是将数字2左移1位，结果为2*2=4
				3 << 2，则是将数字3左移2位，结果为3*(2*2)=12
				3 << 3，则是将数字3左移3位，结果为3*(2*2*2)=24
		2.Java语言中的 <<= 意思为：左移后赋值,相当于乘2后赋值
				如：当x = 5时，
				x <<= 3，则是x = 5*(2*2*2),结果x = 40
		3.Java语言中的 >> 意思为：逻辑右移，相当于除以2
				如：8>>1、8>>2
				8>>1，则是将数字8右移1位，结果为8/2=4
				8>>2，则是将数字8右移2位，结果为8/(2*2)=2
		4.Java语言中的 >>= 意思为：右移后赋值，相当于除以2
				如：当x = 8时，
				x >>= 2，则是x = 8/(2*2),结果x =2
				x >>= 3，则是x = 8/(2*2*2),结果x =1
		5. &, |, ^, !
			逻辑与: 只有当a, b都为true的时候为true
			逻辑或: 只有当a, b 都为false的时候为false
			逻辑异或: a, b 不同则为true, 相同则为false
			逻辑非: !a 结果与a相反
21. 双亲委派机制
		1. 
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
二. 设计模式
	1. 创建型模式
	这类模式提供创建对象的机制, 能够提升已有代码的灵活性和可用性
		1) 工厂方法/Factory Method
		2) 抽象工厂/Abstract Factory 
		3) 生成器/Builder
		4) 原型/Prototype
		5) 单例/Singleton
			1) 饥饿/饿汉模式
				消耗资源
			2) 懒惰模式
				存在线程安全的问题
			3) 静态内部类
			第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 getInstance() 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，
			这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。
			不过，创建单例更优雅的一种方式是使用枚举
			
	2. 结构型模式
	这类模式介绍如何将对象和类组装成较大的结构, 并同时保持结构的灵活和高效
		1) 适配器/Adapter
		2) 桥接/Bridge
		3) 组合/Composite
		4) 装饰/Decorator
		5) 外观/Facade
		6) 享元/Flyweight
		7) 代理/Proxy
	3. 行为模式
	这类模式负责对象间的高效沟通和责任委派
		1) 责任链/Chain of Responsibility
		2) 命令/Command
		3) 迭代器/Iterator
		4) 中介者/Mediator
		5) 备忘录/Memento
		6) 观察者/Observer
		7) 状态/State
		8) 策略/Strategy
		9) 模板方法/Template Method
		10) 访问者/Visitor
************************设计模式的应用场景**************************************
***1. 生产者-消费者模式
		生产者-消费者模式（Producer-Consumer Pattern）是一种经典的并发编程模型，用于解决多个线程之间共享数据的同步问题。
		这种模式通常用于描述两个或多个线程之间的协作关系，其中一个线程（生产者）负责生成数据并将其放入共享缓冲区，
		而另一个线程（消费者）则从缓冲区中取出数据并进行处理。

		在生产者-消费者模式中，生产者和消费者通常通过共享一个有限大小的缓冲区来交互。
		生产者将生成的数据放入缓冲区，而消费者则从缓冲区中取出数据进行处理。
		当缓冲区已满时，生产者会等待直到缓冲区中有空闲空间；当缓冲区为空时，消费者会等待直到缓冲区中有数据可供处理。

		Java 中实现生产者-消费者模式有多种方式，以下是一种使用 java.util.concurrent 包中的 BlockingQueue 接口实现 
		消息中间件都用到了这种设计模式: Java消息服务, Apache Kafka, RabbitMQ, Apache ActiveMQ
			ActiveMQ, RabbitMQ: 万级
			Kafka, RocketMQ: 十万级
***2. 在使用接口的时候，经常会用到三种模式，分别是策略模式、适配器模式和工厂模式。
	1) 策略模式: 策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变。
		根据所传递的参数对象的不同而产生不同的行为，这被称为“策略模式”。
	2) 适配器模式: 适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是HDMI（英语：High Definition Multimedia Interface，中文：高清多媒体接口）线，可以同时发送音频和视频信号。
		Coach 接口中定义了两个方法（defend() 和 attack()），如果类直接实现该接口的话，就需要对两个方法进行实现。
		如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），
		用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。
	3) 工厂模式: 工厂设计模式将对象的创建逻辑封装在工厂类中，客户端只需通过工厂类来创建对象，而无需关心具体的实现细节。这样，对象的创建与使用得以分离，提高了系统的灵活性和可维护性。
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
三. Spring
1. filter和interceptor的区别
	在Java的Web开发中，特别是当使用Servlet和Spring等框架时，
	Filter 和 Interceptor 都是用于处理请求和响应的重要组件。尽管它们在某种程度上具有相似的功能，
	但它们在用途、执行时机和生命周期等方面存在一些关键的区别。

	1). Filter（过滤器）
		Filter 是Java Servlet规范的一部分，用于在请求到达Servlet之前或响应离开Servlet之后执行某些操作。Filter 可以在web.xml中配置，也可以通过注解在Servlet 3.0及以上版本中使用。
		主要功能：
		对请求进行预处理，例如设置请求字符集、记录日志等。
		对响应进行后处理，例如压缩响应数据、设置缓存控制等。
		执行时机：
		在请求到达目标资源（如Servlet）之前执行。
		在响应离开目标资源之后执行。
		特点：
		与具体的Servlet或Controller方法无关，是全局的。
		依赖于Servlet容器，例如Tomcat。
	2). Interceptor（拦截器）
		Interceptor 是Spring框架提供的一个特性，用于在Spring MVC的控制器方法执行前后执行某些操作。它通常用于权限验证、日志记录、事务管理等。
		主要功能：
		在控制器方法执行前执行预处理逻辑。
		在控制器方法执行后执行后处理逻辑。
		在控制器方法执行期间发生异常时执行异常处理逻辑。
		执行时机：
		在控制器方法被调用之前执行。
		在控制器方法返回结果之后执行。
		特点：
		与Spring MVC紧密集成，依赖于Spring框架。
		可以针对特定的控制器或方法进行配置，比Filter更灵活。
		比较
		使用范围：Filter是Servlet规范的一部分，可以在任何支持Servlet的容器中使用。而Interceptor是Spring MVC的一部分，只能在Spring MVC应用中使用。
		灵活性：Interceptor比Filter更灵活，因为它可以针对特定的控制器或方法进行配置。Filter则是全局的，对所有请求都生效。
		依赖：Filter依赖于Servlet容器，而Interceptor依赖于Spring框架。
		功能：两者在功能上有所重叠，但Interceptor通常用于Spring MVC的特定场景，如事务管理、权限验证等，而Filter则更多地用于通用的预处理和后处理操作。
		在实际应用中，可以根据具体需求选择使用Filter还是Interceptor。如果需要在整个应用范围内对请求和响应进行预处理和后处理，那么Filter是一个好选择。
		如果需要在Spring MVC的控制器方法执行前后执行特定逻辑，那么Interceptor可能更合适。
2. Spring、SpringMVC、SpringBoot的区别
			1. Spring是一个开源的Java应用框架，它提供了一套全面的编程和配置模型
			2. Spring MVC是Spring框架中的一个模块，它是基于Java的实现MVC设计模式的请求驱动类型的轻量级Web框架。
			3. Spring Boot是一个用于快速构建现代应用程序的框架，它遵循“约定优于配置”的原则，通过自动化配置和默认设置，减少了繁琐的配置代码，从而简化了开发者的配置工作。
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
四. 数据库
	
	1) 存储过程的优点
		 A、 存储过程允许标准组件式编程
        存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应用程序源代码却毫无影响，从而极大的提高了程序的可移植性。
        B、 存储过程能够实现较快的执行速度
        如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程要比批处理的执行速度快得多。
		因为存储过程是预编译的，在首次运行一个存储过程时，查询优化器对其进行分析、优化，并给出最终被存在系统表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所以速度就要慢一些。
        C、 存储过程减轻网络流量
        对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了网络负载。
        D、 存储过程可被作为一种安全机制来充分利用
        系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。
	2) 并发事务
		事务（Transaction）是访问并可能更新数据库中各项数据项的一个程序执行单元（unit）。 事务由事务开始（begin transaction）和事务结束（end transaction）之间执行的全体操作组成。
		事务的四个特征（ACID）: 原子性（Atomicity）, 一致性（Consistency）, 隔离性（Isolation）, 持久性（Durability）
		分布式事务:
			CAP理论指的是在一个分布式系统中，不能同时满足一致性(Consistency)、可用性(Avalibality)、分区容错性(Partition Tolerance)。
***********并发事务所产生的3个问题
										1. 脏读: 读到了其他事务未提交的数据
										2. 不可重复读: 在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。
										3. 幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。
											更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。
										不可重复读侧重表达 读-读，幻读则是说 读-写，用写来证实读的是鬼影。
***********事务的隔离级别
						上述所说的"脏读"，“不可重复读”，"幻读"这些问题，其实就是数据库读一致性问题，必须由数据库提供的事务隔离机制来进行解决。
										1. 读未提交: 没有隔离效果
										2. 读已提交: 解决脏读, Oracle默认隔离级别
										3. 可重复读: 解决脏读, 不可重复读. MySQL默认事务隔离级别.
										4. 串行化: 解决脏读, 不可重复读, 幻读. 读的时候加共享锁, 其他事务可以并发读不能写. 写的时候加上排他锁/独占锁/写锁, 其他事务不能并发写也不能并发读.
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
五. 操作系统
	1) 进程: 是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。
		线程: 是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。
	2). CMD
		1) ping 主机, telnet 端口
		2) jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、ClassLoader 的信息以及 finalizer 队列等。

	3. 7层架构

		物理层, 数据链路层, 
		网络层, 传输层,  会话层,  
		表示层, 应用层		

*******************************************
SAP

1. 邮件问题
	1) HI it::可以帮我看一下吗？这个工单我们的 IT 处理但是他们从新抛两次本来工单只做完8PCS而已，现在抛多一次所以抛多8PCS了！！你可以帮我取消一次吗？？
		IT不能在正式環境作業，你用CO13 cancel掉一筆就行（如果你沒有CO13權限，找倉庫）。		 
2. 账号密码管理
	解锁二阶账号: ztlogin03
	更改二阶账号密码: ztlogin01(要输入一阶账号)
	修改/解锁一阶账号密码: su01(在tab bar)		
3.  
		 

		 
		 

