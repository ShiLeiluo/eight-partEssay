***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
一、8种基本数据类型
		1000 1110共有八个位，它的英文名字叫（bit），是计算机中最基本的单位。
		Byte，是由八个位组成的一个单元,A便用 “0100 0001”来表示,8位一个字节
		

	4大类
	1) 逻辑类型: 
		boolean(8位, 1字节)
		1)) 布尔类型占1个字节（8位），它的的值，必须是true或者false。
		2)) 在JVM中会转换为1（true）或者0（false）。
	2) 整型: 
	byte(8位, 1字节)
	short(16位, 2字节)
	int(32位, 4字节)
	long(64位, 8字节)
	3) 浮点型:
	float
	1)) 内存中占32位, 1符号位+8指数位+23尾数。
	2)) float的精度为7位左右有效数字。
	3)) float浮点型数据的声明：后面加f或者F。
	double
	1)) 内存中占64位 1符号位+11指数位+52尾数位。
	2)) double的精度为16位左右有效数字。
	3)) double浮点型数据的声明：后面加d或者D。
	4) 字符型:
	char
	1)) char类型占2个字节（16位），用来表示字符。
	2)) char是基本数据类型。String表示字符串，是类类型。一个String是由0~n个char组成。
	3)) 字符使用单引号表示，字符串使用双引号表示
***********************************************************************************************	
***********************************************************************************************
	数据类型	      默认值	      大小
	boolean	      false	          1 比特/1位
	char	      '\u0000'	      2 字节
	byte	            0	              1 字节
	short	            0	              2 字节
	int	                0	              4 字节
	long	            0L	          8 字节
	float	            0.0f	          4 字节
	double	        0.0	          8 字节
	
	1 Byte/字节 = 8 Bit/位/比特
	1 KB             =   1024 Byte
	1 MB            =   1024 KB
	1 GB            =    1024 M
	1 TB             =    1024 GB
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
二、常见的数据结构

		1) 数组(Arrary)
			连续的内存空间存储同类型的数据。
			优点：查询效率高，随机访问性强。
			缺点：大小固定，不易动态扩展，插入和删除数据效率低。
		2) 链表(Linked List)
			节点之间通过指针或引用相连，形成链式结构。
			优点：内存占用宽松，扩展灵活，不需要连续的内存空间。
			缺点：查询效率低，需要从头节点开始遍历。
		3) 栈(Stack)
			遵循后进先出（LIFO）原则的数据结构。
			通常用于实现方法调用、表达式求值等。
		4) 队列(Queue)
			遵循先进先出（FIFO）原则的数据结构。
			常用于实现缓冲区、任务调度等。
		5) 树(Tree)
			一种非线性的数据结构，具有层次关系。
			常见类型有：二叉树、红黑树、AVL树、B树、B+树等。
			广泛用于数据库索引、文件系统、搜索引擎等。
		6) 图(Gragh)
			由顶点和边组成的数据结构，表示对象之间的多对多关系。
			常用于表示网络、社交关系等。
		7) 哈希表(Hash Table)
			通过哈希函数将键映射到存储位置的数据结构。
			优点：查询、插入和删除操作的平均时间复杂度为O(1)。
			Java中的HashMap就是哈希表的一种实现。
		8) 堆(Heap)
			一种特殊的树形数据结构，用于实现优先队列。
			最大堆：父节点值大于等于子节点值，常用于实现最大数据项的快速读取。
			最小堆：父节点值小于等于子节点值，常用于实现最小数据项的快速读取。
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
三、Java的集合框架/Java集合框架是基本数据结构在Java语言中的实现和描述。
Java集合框架和基本数据结构之间有着密切的关系。简单来说，Java集合框架是基本数据结构在Java语言中的实现和描述。

基本数据结构，如数组、链表、栈、队列、树和图等，是计算机科学中用于组织和存储数据的基本方式。每种数据结构都有其特定的特性和适用场景。
例如，数组适合用于存储连续且类型相同的数据，而链表则适合用于动态地添加和删除元素。

Java集合框架将这些基本数据结构进行了封装和抽象，提供了统一的接口和实现类。这使得开发者可以更加便捷地使用这些数据结构，而无需关心底层的实现细节。
Java集合框架中的接口定义了操作集合的通用方法，如添加、删除、查找等，而实现类则提供了这些方法的具体实现。

Java集合框架中的实现类通常都是基于基本数据结构进行实现的。例如，ArrayList和LinkedList就是基于数组和链表这两种基本数据结构实现的List接口。
HashSet和TreeSet则是基于哈希表和红黑树这两种基本数据结构实现的Set接口。

因此，可以说Java集合框架和基本数据结构是相互依存的。基本数据结构为Java集合框架提供了底层支持，而Java集合框架则为开发者提供了使用这些基本数据结构的便捷方式。

Collection，主要由 List、Set、Queue 组成，List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；
Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQueue。
Map，代表键值对的集合，典型代表就是 HashMap。
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
****1. Collection
		1) Set/接口/继承Collection接口
		Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。
			1)) EnumSet
			EnumSet 是 Java 中的一个特殊集合，用于存储枚举类型的元素
			2)) SortedSet/接口/继承自Set
				@@@1))) TreeSet/类/SortedSet实现类
				
				TreeSet 是由 TreeMap（后面会讲） 实现的
				与 TreeMap 相似，TreeSet 是一种基于红黑树实现的有序集合，它实现了 SortedSet 接口，可以自动对集合中的元素进行排序。按照键的自然顺序或指定的比较器顺序进行排序。
				TreeSet 不允许插入 null 元素，否则会抛出 NullPointerException 异常。(因为要比较大小排序, null无法与任何值比较)
				
			@@@3)) HashSet/类/Set实现类
			HashSet 其实是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作
			实际开发中，HashSet 并不常用，比如，如果我们需要按照顺序存储一组元素，那么 ArrayList 和 LinkedList 可能更适合；
			如果我们需要存储键值对并根据键进行查找，那么 HashMap 可能更适合。
			HashSet 主要用于去重，比如，我们需要统计一篇文章中有多少个不重复的单词，就可以使用 HashSet 来实现。
			允许插入一个 null 
			
			@@@4)) LinkedHashSet/类/Set实现类/继承自HashSet
			LinkedHashSet 虽然继承自 HashSet，其实是由 LinkedHashMap 实现的。
			LinkedHashSet 是一种基于哈希表实现的 Set 接口，它继承自 HashSet，并且使用链表维护了元素的插入顺序。
			因此，它既具有 HashSet 的快速查找、插入和删除操作的优点，又可以维护元素的插入顺序。
			允许插入一个 null
			
		2) Queue/接口/继承自Collection接口
		队列(Queue)：队列简称队，也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列中插入元素称为入队或进队；删除元素称为出队或离队。
		符合先进先出(First In First Out/FIFO)的设计原则
		
		@@@LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。
				1)) offer: 添加元素到队尾, 返回值: boolean
				2)) poll: 获取队首元素并删除, 返回值: 队首元素
				3)) peek: 获取队首元素
				add()和remove()方法在失败的时候会抛出异常(不推荐)
				Queue是一个队列规范的接口，Deque是一个双端队列实现的接口，由于两个都是接口，所以是不能直接进行是实例化的，需要接口引用具体的类来进行实例化，
				所以底层可以是顺序表（数组），也可以是链表（单 / 双链表）。
				
			@@@1)) Deque/queue的子接口
				1)))ArrayDeque/Deque实现类
				当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列）
				基于数组实现的线性双向队列，通常作为栈或队列使用，但是栈的效率不如LinkedList高。
				
				ArrayDeque是 Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。同时， ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。
				ArrayDeque是 Deque的实现类，可以作为栈来使用，效率高于 Stack；也可以作为队列来使用，效率高于 LinkedList。
				ArrayDeque 是 Java 集合中双端队列的数组实现，双端队列的链表实现（LinkedList）
				需要注意的是， ArrayDeque不支持 null值。
			@@@2)) PriorityQueue/优先级队列
				PriorityQueue 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。
			
		3) List/接口/继承Collection接口
			@@@1)) LinkedList/List实现类
			LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。
			基于 链表 实现的链式双向队列，通常作为栈或队列使用，但是队列的效率不如ArrayQueue高
			特点
			1.插入、删除、获取操作支持两种形式：快速失败和返回null或true/false
			2.既具有FIFO特点又具有LIFO特点，即是队列又是栈
			3.不推荐插入null元素，null作为特定返回值表示队列为空
			4.未定义基于元素相等的equals和hashCode
			@@@2)) ArrayList/List实现类
			初始容量10, 扩容因子1.5(添加第 10 个元素时，容量会增加到 15（即 10 * 1.5）)
			ArrayList 是由 数组 实现的，支持随机存取，也就是可以通过下标直接存取元素；
			从尾部插入和删除元素会比较快捷，从中间插入和删除元素会比较低效，因为涉及到数组元素的复制和移动；
			如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。
			3)) Vector
			初始容量10, 扩容因子翻倍
				add, remove, get
				线程安全
		
****2. Map
		1) EnumMap
		2) IdentityHashMap
		3) HashMap
		map.computeIfAbsent(key, k->"").subString(), map.getOrDefault()
		HashMap 中的键和值都可以为 null。如果键为 null，则将该键映射到哈希表的第一个位置。
		可以使用迭代器或者 forEach 方法遍历 HashMap 中的键值对。
		默认的初始容量是 16，负载因子是 0.75。
		HashMap 的实现原理是基于哈希表的，它的底层是一个数组，数组的每个位置可能是一个链表或红黑树，
		也可能只是一个键值对（后面会讲）。当添加一个键值对时，HashMap 会根据键的哈希值计算出该键对应的数组下标（索引），然后将键值对插入到对应的位置。
		HashMap 是 Java 中常用的数据结构之一，用于存储键值对。在 HashMap 中，每个键都映射到一个唯一的值，可以通过键来快速访问对应的值，算法时间复杂度可以达到 O(1)。

		当通过键查找值时，HashMap 也会根据键的哈希值计算出数组下标，并查找对应的值。
			1)) LinkedHashMap
		4) HashTable
		Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。
			1)) Properties
			Properties是一个Map集合，继承Hashtable，Properties的key和value都是String类型。 Properties被称为属性类对象。 Properties是线程安全的。
		5) WeakHashMap
		6) SortedMap
			1) TreeMap
			
***Comparable 和 Comparator 两者之间的区别：*******************************************

	Comparable用法：对需要排序的类，实现Comparable接口，重写compareTo()方法。
	Comparator用法：创建自定义比较器，实现Comparator接口，重写compare()方法。还可以通过匿名类的方式更快速便捷的完成自定义比较器的功能。

一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。
一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。
Comparable 接口在 java.lang 包下，而 Comparator 接口在 java.util 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。

Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。

Collection与Collections的区别
Collection是集合类的上级接口，继承与他有关的接口主要有List和Set
Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作
***compute, computeIfAbsent, computeIfPresent*******************************************
	compute: 
	computeIfAbsent:
	computeIfPresent:
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------				
****3. Stack
		1) Java 里有一个叫做Stack的类，却没有叫做Queue的类（它只是个接口名字，和类还不一样）。
		当需要使用栈时，Java 已不推荐使用Stack，而是推荐使用更高效的ArrayDeque（双端队列），
		原因我们第一次讲集合框架的时候，其实已经聊过了，Stack 是一个“原始”类，
		它的核心方法上都加了 synchronized 关键字以确保线程安全，当我们不需要线程安全（比如说单线程环境下）性能就会比较差。
		
		遵循后进先出原则的数据结构(Last In First Out/LIFO)/线性数据结构
		
		Java 已经帮我们实现了一个栈，就是 java.util.Stack，它继承自 Vector，是线程安全的，有点 StringBuffer 的感觉，笨笨的。
		
		1))  Stack是Vector的一个子类，它实现标准的后进先出堆栈。
		栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。
		
		主要有5个
		
			1))) push: 将项压入栈顶
			2))) pop: 移除栈顶对象，并作为此函数的值返回该对象。
			3))) peek: 查看栈顶对象而不移除它。
			4))) search: 返回对象在堆栈中的位置，以 1 为基数。(从顶向下数，从1开始计数)找不到返回-1
			5))) empty: 判断栈是否为空, 返回值为 boolean类型
		
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------
&&&&4. Java的并发容器
					Java 的并发集合容器提供了在多线程环境中高效访问和操作的数据结构。这些容器通过内部的同步机制实现了线程安全，
					使得开发者无需显式同步代码就能在并发环境下安全使用，比如说：ConcurrentHashMap、阻塞队列(BlockingQueue: ArrayBlockingQueue)
					和 CopyOnWrite 容器等。

					java.util 包下提供了一些容器类（集合框架），其中 Vector 和 Hashtable 是线程安全的，但实现方式比较粗暴，通过在方法上加「sychronized」关键字实现。

					但即便是 Vector 这样线程安全的类，在应对多线程的复合操作时也需要在客户端继续加锁以保证原子性。
					
					1) Queue
						1)) BlockingQueue/阻塞队列
							1))) ArrayBlockingQueue
							2))) PriorityBlockingQueue
							3))) SynchronousQueue
							4))) DelayQueue
							5))) LinkedBlockingQueue
							
							6))) BlockingDeque
							7))) LinkedBlockingDeque
							
							8))) TransferQueue
							9))) LinkedTransferQueue
					2) ConcurrentMap
						1)) ConcurrentHashMap ***
						2)) ConcurrentNavigableMap
						3)) ConcurrentSkipListMap
							
					3) CopyOnWrite
						1)) CopyOnWriteArraySet
						2)) CopyOnWriteArrayList ***
						3)) ConcurrentLinkedDeque
						4)) ConcurrentLinkedQueue
						5)) ConcurrentSkipListMap
------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------		
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
四、Java IO		
			字节流可以处理一切文件，而字符流只能处理文本。
			虽然 IO 类很多，但核心的就是 4 个抽象类：InputStream、OutputStream、Reader、Writer。
			虽然 IO 类的方法也很多，但核心的也就 2 个：read 和 write。
			
			字节流和字符流的区别：

			字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。字符流一般用于处理纯文本类型的文件，如TXT文件等，
			但不能处理图像视频等非文本文件。用一句话说就是：字节流可以处理一切文件，而字符流只能处理纯文本文件。
			字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。
			而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。
			按照 IO 的操作对象来思考，IO 就可以分类为：文件、数组、管道、基本数据类型、缓冲、打印、对象序列化/反序列化，以及转换等。
*********1. 字节流
					1. 字节流用来处理二进制文件，比如说图片啊、MP3 啊、视频啊。

*********2. 字符流
					1. 字符流用来处理文本文件，文本文件可以看作是一种特殊的二进制文件，只不过经过了编码，便于人们阅读。
					
		1）文件
文件流也就是直接操作文件的流，可以细分为字节流（FileInputStream 和 FileOuputStream）和字符流（FileReader 和 FileWriter）。
		2）数组（内存）
通常来说，针对文件的读写操作，使用文件流配合缓冲流就够用了，但为了提升效率，频繁地读写文件并不是太好，那么就出现了数组流，有时候也称为内存流。
		3）管道
Java 中的管道和 Unix/Linux 中的管道不同，在 Unix/Linux 中，不同的进程之间可以通过管道来通信，但 Java 中，
通信的双方必须在同一个进程中，也就是在同一个 JVM 中，管道为线程之间的通信提供了通信能力。
一个线程通过 PipedOutputStream 写入的数据可以被另外一个线程通过相关联的 PipedInputStream 读取出来。

使用管道流可以实现不同线程之间的数据传输，可以用于线程间的通信、数据的传递等。
但是，管道流也有一些局限性，比如只能在同一个 JVM 中的线程之间使用，不能跨越不同的 JVM 进程。
		4）基本数据类型
基本数据类型输入输出流是一个字节流，该流不仅可以读写字节和字符，还可以读写基本数据类型。
DataInputStream 提供了一系列可以读基本数据类型的方法
DataOutputStream 提供了一系列可以写基本数据类型的方法
除了 DataInputStream 和 DataOutputStream，Java IO 还提供了其他一些读写基本数据类型和字符串的流类，
包括 ObjectInputStream 和 ObjectOutputStream（用于读写对象）
		5）缓冲
CPU 很快，它比内存快 100 倍，比磁盘快百万倍。那也就意味着，程序和内存交互会很快，和硬盘交互相对就很慢，这样就会导致性能问题。

为了减少程序和硬盘的交互，提升程序的效率，就引入了缓冲流，也就是类名前缀带有 Buffer 的那些，比如说 BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。
		6）打印
Java 的打印流是一组用于打印输出数据的类，包括 PrintStream 和 PrintWriter 两个类。

恐怕 Java 程序员一生当中最常用的就是打印流了：System.out 其实返回的就是一个 PrintStream 对象，可以用来打印各式各样的对象。
		7）对象序列化/反序列化
序列化本质上是将一个 Java 对象转成字节数组，然后可以将其保存到文件中，或者通过网络传输到远程。
		8）转换
InputStreamReader 是从字节流到字符流的桥连接，它使用指定的字符集读取字节并将它们解码为字符。
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
五、异常处理
***********************************************************************************************
***********************************************************************************************
1. Exception和Error的区别
从单词的释义上来看，error 为错误，exception 为异常，错误的等级明显比异常要高一些。

从程序的角度来看，也的确如此。

Error 的出现，意味着程序出现了严重的问题，而这些问题不应该再交给 Java 的异常处理机制来处理，
程序应该直接崩溃掉，比如说 OutOfMemoryError，内存溢出了，这就意味着程序在运行时申请的内存大于系统能够提供的内存，导致出现的错误，这种错误的出现，对于程序来说是致命的。

Exception 的出现，意味着程序出现了一些在可控范围内的问题，我们应当采取措施进行挽救。

比如说之前提到的 ArithmeticException，很明显是因为除数出现了 0 的情况，我们可以选择捕获异常，
然后提示用户不应该进行除 0 操作，当然了，更好的做法是直接对除数进行判断，如果是 0 就不进行除法运算，而是告诉用户换一个非 0 的数进行运算。

2. checked和unchecked异常
checked 异常（检查型异常）在源代码里必须显式地捕获或者抛出，否则编译器会提示你进行相应的操作；
而 unchecked 异常（非检查型异常）就是所谓的运行时异常，通常是可以通过编码进行规避的，并不需要显式地捕获或者抛出。
@@@Throwable
	1) Exception
		1)) CheckedException
			 IOException
			 SQLException
			 ClassNotFoundException
		2)) UncheckedException
			 NullPointerException
			 ArrayIndexOutOfBoundsException
			 IllegalArgumentException
	2) Error
		OutOfMemoryError
		StackOverflowError
		NoClassDefFoundError
首先，Exception 和 Error 都继承了 Throwable 类。换句话说，只有 Throwable 类（或者子类）的对象才能使用 throw 关键字抛出，或者作为 catch 的参数类型。

面试中经常问到的一个问题是，NoClassDefFoundError 和 ClassNotFoundException 有什么区别？
        它们都是由于系统运行时找不到要加载的类导致的，但是触发的原因不一样。
		NoClassDefFoundError：程序在编译时可以找到所依赖的类，但是在运行时找不到指定的类文件，导致抛出该错误；原因可能是 jar 包缺失或者调用了初始化失败的类。
		ClassNotFoundException：当动态加载 Class 对象的时候找不到对应的类时抛出该异常；原因可能是要加载的类不存在或者类名写错了。
3. 关于throw和throws
		throw: “throw 关键字，用于主动地抛出异常；正常情况下，当除数为 0 的时候，程序会主动抛出 ArithmeticException；
		但如果我们想要除数为 1 的时候也抛出 ArithmeticException，就可以使用 throw 关键字主动地抛出异常。
		throws 关键字的作用就和 throw 完全不同
		对于检查型异常来说，如果你没有做处理，编译器就会提示你
		1）throws 关键字用于声明异常，它的作用和 try-catch 相似；而 throw 关键字用于显式的抛出异常。

		2）throws 关键字后面跟的是异常的名字；而 throw 关键字后面跟的是异常的对象。
		
finally不执行的情况
	遇到了死循环。
	执行了 System. exit() 这行代码。
System.exit() 和 return 语句不同，前者是用来退出程序的，后者只是回到了上一级方法调用

4. try-catch-resource
try-with-resources语句是一种声明了一种或多种资源的try语句。资源是指在程序用完了之后必须要关闭的对象。
try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。任何实现了java.lang.AutoCloseable接口的对象，和实现了java.io.Closeable接口的对象，都可以当做资源使用。

如果一个类实现了 AutoCloseable 接口，并行重写 close 方法。那么这个类就可以写在try-catch的try后面的括号中，并且能在try-catch块执行后自动执行这个方法。

建议使用try-with-resources替代try-cache-finall，使代码更简洁，开发更容易。

***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
六、常用工具类
1. Scanner
2. Arrays
3. StringUtils
4. Objects
5. Collections
6. Hutool
7. Guava
8. 其他IPUtil、CollectionUtils、MDC、ClassUtils、BeanUtils、ReflectionUtils
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
七、Java新特性(流Stream/Optional/Lambda)
1. 掌握Stream流
	Java Stream流是Java 8 API添加的一个新的抽象，用于处理数据集合。Stream是一个来自数据源的元素队列，元素是特定类型的对象，形成一个队列。
	这个数据源可以是集合、数组等，而Stream并不会存储元素，而是按需计算。
	Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。它的主要目的在于计算，而不是存储数据。
	通过Stream，程序员可以以一种声明性的方式处理数据集合，这侧重于对源数据计算能力的封装，并支持序列与并行两种操作方式。
	Stream是对集合（Collection）对象功能的增强，与Lambda表达式结合，可以提高编程效率、间接性和程序可读性。它让程序员能够写出高效率、干净、简洁的代码。
	Stream的使用步骤通常包括：得到集合/数组Stream流对象，创建Stream对象，然后调用Stream类相关API进行数据加工处理。
	Stream流的三类方法主要包括：获取Stream流、创建一条流水线并把数据放到流水线上准备进行操作，以及流水线上的中间方法操作。

总结来说，Java Stream流是一个强大的工具，它提供了一种灵活且高效的方式来处理数据集合，使得Java程序员能够更简洁、更直观地表达复杂的集合操作。
要想操作流，首先需要有一个数据源，可以是数组或者集合。每次操作都会返回一个新的流对象，方便进行链式操作，但原有的流对象会保持不变。

流的操作可以分为两种类型：

1）中间操作，可以有多个，每次返回一个新的流，可进行链式操作。

2）终端操作，只能有一个，每次执行完，这个流也就用光光了，无法执行下一个操作，因此只能放在最后。
如果是数组的话，可以使用 Arrays.stream() 或者 Stream.of() 创建流；如果是集合的话，可以直接使用 stream() 方法创建流，因为该方法已经添加到 Collection 接口中。
1）过滤
通过 filter() 方法可以从流中筛选出我们想要的元素。
2）映射
如果想通过某种操作把一个流中的元素转化成新的流中的元素，可以使用 map() 方法。
3）匹配
Stream 类提供了三个方法可供进行元素匹配
4）组合
reduce() 方法的主要作用是把 Stream 中的元素组合起来
03、转换流
既然可以把集合或者数组转成流，那么也应该有对应的方法，将流转换回去——collect() 方法就满足了这种需求。
2. Optional
Optional<String> empty = Optional.empty();
ifPresent()
Optional.ofNullable(null) (StringBuilder sb, sb.setLength(0))
Predicate 是 Java 8 中引入的一个函数式接口，它属于 java.util.function 包。Predicate 接口代表了一个谓词，
即一个返回布尔值的函数。它通常用于测试或过滤元素，例如在集合的 stream() 操作中。

Predicate<Integer> isEven = num -> num % 2 == 0; 
3. Java 8 Lambda表达式
Lambda 表达式描述了一个代码块（或者叫匿名方法），可以将其作为参数传递给构造方法或者普通方法以便后续执行。
( parameter-list ) -> { expression-or-statements }

:: 双冒号运算操作符是类方法的句柄，lambda表达式的一种简写，这种简写的学名叫eta-conversion或者叫η-conversion。
 forEach(System.out::print)
***********************************************************************************************
***********************************************************************************************
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
八、网络编程
Socket
DatagramSocket 类是 Java 中实现 UDP 协议的核心类。与基于 TCP 的 Socket 和 ServerSocket 类不同，
DatagramSocket 类提供了无连接的通信服务，发送和接收数据包。由于无需建立连接，UDP 通常比 TCP 更快，但可能不如 TCP 可靠。
九、Java NIO
传统 IO 基于字节流或字符流（如 FileInputStream、BufferedReader 等）进行文件读写，以及使用 Socket 和 ServerSocket 进行网络传输。
NIO 使用通道（Channel）和缓冲区（Buffer）进行文件操作，以及使用 SocketChannel 和 ServerSocketChannel 进行网络传输。
传统 IO 采用阻塞式模型，对于每个连接，都需要创建一个独立的线程来处理读写操作。当一个线程在等待 I/O 操作时，无法执行其他任务。这会导致大量线程的创建和销毁，以及上下文切换，降低了系统性能。

NIO 使用非阻塞模型，允许线程在等待 I/O 时执行其他任务。这种模式通过使用选择器（Selector）来监控多个通道（Channel）上的 I/O 事件，实现了更高的性能和可伸缩性。

BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。
NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。
AIO 方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。
***********************************************************************************************
***********************************************************************************************
十一、Java重要知识点
	1. Java命名规范
		1) 包
			1. 应该全部是小写字母
			2. 点分隔符之间有且仅有一个自然语义的英语单词
			3. 包名统一使用单数形式***，比如说 com.itwanger.util 不能是 com.itwanger.utils 
			4. 在最新的 Java 编程规范中，要求开发人员在自己定义的包名前加上唯一的前缀。
				由于互联网上的域名是不会重复的，所以多数开发人员采用自己公司（或者个人博客）在互联网上的域名称作为包的唯一前缀。
				比如我文章中出现的代码示例的包名就是 package com.itwanger。
		2) 类
			类的命名应该遵守以下规则：
			1. 必须以大写字母开头
			2. 最好是一个名词，比如说 System
			3. 类名使用 UpperCamelCase（驼峰式命名）风格
			4. 尽量不要省略成单词的首字母，但以下情形例外：DO/BO/DTO/VO/AO/PO/UID 等
		另外，如果是抽象类的话，使用 Abstract 或 Base 开头；如果是异常类的话，使用 Exception 结尾；如果是测试类的话，使用 Test 结尾。
		3) 接口
			接口的命名应该遵守以下规则：
			1. 必须以大写字母开头
			2. 最好是一个形容词，比如说 Runnable
			3. 尽量不要省略成单词的首字母		
		接口和实现类之间也有一些规则：
		实现类用 Impl 的后缀与接口区别，比如说 CacheServiceImpl 实现 CacheService 接口
		或者，AbstractTranslator 实现 Translatable 接口		
		4) 字段（field）和变量（variable）
		5) 常量 (constant)
		6) 方法
			总结一下：
		除了以上这些规则以外，还有一些共同的规则需要遵守，比如说：
		1. 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例：_name / __name / $name / name_ / name$ / name__
		2. 所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。反例：DaZhePromotion [打折] / getPingfenByName() [评分] / String fw[福娃] / int 某变量 = 3
		3. 代码和注释中都要避免使用任何语言的种族歧视性词语。反例：RIBENGUIZI / Asan / blackList / whiteList / slave
			方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。
		3. 杜绝完全不规范的缩写，避免望文不知义。反例：AbstractClass “缩写”成 AbsClass；condition “缩写”成 condi；Function 缩写”成 Fu，此类随意缩写严重降低了代码的可阅读性。
		4. 为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达。
		5. 在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。正例：startTime / workQueue / nameList / TERMINATED_THREAD_COUNT
		6. 如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。比如说：public class OrderFactory;public class LoginProxy;public class ResourceObserver;
		7. 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。枚举其实就是特殊的常量类，且构造方法被默认强制是私有。比如说：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。
	2. 中文乱码及字符编码全攻略
	3. 拆箱和装箱
	4. 深入理解Java浅拷贝与深拷贝
	5. Java HashCode方法解析
	6. Java是值传递还是引用传递
	7. Java为什么无法实现真正的泛型
	8. 掌握Java反射
		1) 反射的缺点主要有2个
			1. 破坏封装：由于反射允许访问私有字段和私有方法，所以可能会破坏封装而导致安全问题。
			2. 性能开销：由于反射涉及到动态解析，因此无法执行 Java 虚拟机优化，再加上反射的写法的确要复杂得多，
			所以性能要比“正射”差很多，在一些性能敏感的程序中应该避免使用反射。
		2) 反射的好处
			1. 提高程序的灵活性和扩展性: 动态创建, 控制类, 降低了模块的耦合性
			2. 方便获取类信息: 运行时得到变量,方法
				访问私有方法和字段时，我们需要调用 setAccessible(true) 方法来允许访问
			3. 提高代码复用率: 框架基础
		3) 应用场景
			1. 开发通用框架：像 Spring，为了保持通用性，通过配置文件来加载不同的对象，调用不同的方法。
			2. 动态代理：在面向切面编程中，需要拦截特定的方法，就会选择动态代理的方式，而动态代理的底层技术就是反射。
			3. 注解：注解本身只是起到一个标记符的作用，它需要利用发射机制，根据标记符去执行特定的行为。
		4) 步骤
			geClass()->getConstructor()->getNewInstace()->getMethod()->invoke()
			获取Class对象->获取构造方法 Constructor 对象->初始化反射类对象->获取要调用的方法的 Method 对象->通过 invoke() 方法执行
				总结一下：
		反射是 Java 中的一个强大特性，它允许在运行时检查和操作类、接口、字段和方法。反射是 Java 的核心组件，支持各种框架和库的实现，
		如 Spring、Hibernate 等。使用反射，可以在运行时动态地创建对象、调用方法和访问字段，而无需在编译时了解这些对象的具体实现。
			反射的主要类位于 java.lang.reflect 包中，主要包括以下几个关键类：
		1. Class：代表一个类或接口，包含了类的结构信息（如名称、构造函数、方法、字段等）。通过 Class 对象，可以获取类的元数据并操作类的实例。
		2. Constructor：代表类的构造方法，用于创建类的实例。
		3. Method：代表类的方法，可以通过它调用类的实例方法。
		4. Field：代表类的字段，可以获取或修改字段的值。
		5. Modifier：包含方法、字段和类的访问修饰符（如 public、private 等）。
			使用反射时，需要注意以下几点：
		1. 性能：反射操作通常比直接操作对象的方法和字段慢，因为涉及到额外的间接调用和动态解析。因此，在关注性能的场景中，慎用反射。
		2. 安全性：通过反射，可以访问和操作类的私有字段和方法，这可能导致安全问题。因此，使用反射时要确保代码的安全性。
		3. 维护性：反射使代码变得更加复杂，可能导致难以维护。在使用反射时要确保代码的可读性和可维护性。
			尽管反射存在上述问题，但在某些场景下（如框架开发、动态代理等），它仍然是非常有用的工具。
***********************************************************************************************
***********************************************************************************************
十一、并发编程
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
****************************************************************************************************************
1. 创建线程的三种方式
1) 继承Thread类
Thread类本质上是实现了Runnable接口的一个实例，代表一个线程。通过Thread类的start()实例方法来启动线程。
start()方法是一个native方法（native方法：一个java调用而非java代码的接口），他会启动一个新线程，并执行run()方法。
创建一个类继承 Thread 类，并重写 run 方法。
定义Thread的子类，并重写run()方法，该方法的方法体就是线程需要完成的任务，run()方法也成为线程执行体

创建Thread子类的实例，也就是创建了线程对象
调用现成的start()方法，启动线程
2) 实现Runnble接口
创建一个类实现 Runnable 接口，并重写 run 方法。
实现Runnable接口创建线程步骤
定义Runnable实现类的实例，并重写run()方法，这个run()方法也是线程执行体

创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象
然后通过调用线程对象的start()方法来启动线程
3) 实现Callable接口
实现 Callable 接口，重写 call 方法，这种方式可以通过 FutureTask 获取任务执行的返回值。

2. 控制线程的4个常用方法
	1. sleep()
	使当前正在执行的线程暂停指定的毫秒数，也就是进入休眠的状态。
	需要注意的是，sleep 的时候要对异常进行处理。
	2. join()
	等待这个线程执行完才会轮到后续线程得到 cpu 的执行权，使用这个也要捕获异常。
	3. setDaemon()
	// 守护线程在主线程操作完成后就会自动退出，所以不适合进行读写操作
	将此线程标记为守护线程，准确来说，就是服务其他的线程，像 Java 中的垃圾回收线程，就是典型的守护线程。
	4. yield()
	yield() 方法是一个静态方法，用于暗示当前线程愿意放弃其当前的时间片，允许其他线程执行。
	然而，它只是向线程调度器提出建议，调度器可能会忽略这个建议。具体行为取决于操作系统和 JVM 的线程调度策略。
3. 获取Java线程执行结果: Callable、Future、FutureTask	
	1. 有返回值的 Callable
		Callable 位于 java.util.concurrent 包下，也是一个接口，它定义了一个 call() 方法
		一般会配合 ExecutorService（后面在讲线程池的时候会细讲，这里记住就行）来使用。
		ExecutorService 是一个接口，位于 java.util.concurrent 包下，它是 Java 线程池框架的核心接口，
		用来异步执行任务。它提供了一些关键方法用来进行线程管理。
		我们通过 Executors 工具类来创建一个 ExecutorService，然后向里面提交 Callable 任务，然后通过 Future 来获取执行结果。
		ExecutorServices.submit() = Future
		使用 Runnable 的方式要比 Callable 的方式简单一些，但是 Callable 的方式可以获取执行结果，这是 Runnable 做不到的。
	2. 异步计算结果Future接口
		我们通过 Future 来获取 Callable 任务的执行结果，那么 Future 是什么呢
		Future 位于 java.util.concurrent 包下，它是一个接口：
		一共声明了5种方法: cancel()、isCanclled()、isDone()、get()、get(long timeout, TimeUnit uint)
		
		也就是说 Future 提供了三种功能：
		1）判断任务是否完成；
		2）能够中断任务；
		3）能够获取任务执行结果。
		由于 Future 只是一个接口，如果直接 new 的话，编译器是会有一个 ⚠️ 警告的，它会提醒我们最好使用 FutureTask。
		实际上，FutureTask 是 Future 接口的一个唯一实现类，我们在前面的例子中 executorService.submit() 返回的就是 FutureTask
	3. 异步执行结果FutureTask实现类
		FutureTask 类实现了 RunnableFuture 接口
		RunnableFuture 继承了 Runnable 接口和 Future 接口，而 FutureTask 实现了 RunnableFuture 接口。
		所以它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值。
		当需要异步执行一个计算并在稍后的某个时间点获取其结果时，就可以使用 FutureTask
4. Java线程的6种状态及切换
		操作系统的线程主要有以下三个状态：

		就绪状态(ready)：线程正在等待使用 CPU，经调度程序调用之后进入 running 状态。
		执行状态(running)：线程正在使用 CPU。
		等待状态(waiting): 线程经过等待事件的调用或者正在等待其他资源（如 I/O）。
5. Java线程的6种状态
		// Thread.State 源码
		public enum State {
			NEW,
			RUNNABLE,
			BLOCKED,
			WAITING,
			TIMED_WAITING,
			TERMINATED;
		}
	1) NEW
		处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是还没调用 Thread 实例的start()方法。
		*关于 start 的两个引申问题
		反复调用同一个线程的 start 方法是否可行？
		假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start 方法是否可行？

		都不行，在调用 start 之后，threadStatus 的值会改变（threadStatus !=0），再次调用 start 方法会抛出 IllegalThreadStateException 异常。
		threadStatus 为 2 代表当前线程状态为 TERMINATED（下面会讲）。
	2) Runnable
		表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。
		也就是说，Java 线程的RUNNABLE状态其实包括了操作系统线程的ready和running两个状态.
	3) BLOCKED
		阻塞状态。处于 BLOCKED 状态的线程正等待锁（锁会在后面细讲）的释放以进入同步区。
		我们用 BLOCKED 状态举个生活中的例子：
		假如今天你下班后准备去食堂吃饭。你来到食堂仅有的一个窗口，发现前面已经有个人在窗口前了，此时你必须得等前面的人从窗口离开才行。
		假设你是线程 t2，你前面的那个人是线程 t1。此时 t1 占有了锁（食堂唯一的窗口），t2 正在等待锁的释放，所以此时 t2 就处于 BLOCKED 状态。
	4) WAITING
		等待状态。处于等待状态的线程变成 RUNNABLE 状态需要其他线程唤醒。
		调用下面这 3 个方法会使线程进入等待状态：
		Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；
		Thread.join()：等待线程执行完毕，底层调用的是 Object 的 wait 方法；
		LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度。LockSupport 我们在后面会细讲。
		***当线程调用wait方法时，它会释放当前持有的对象锁
	5) TIMED_WAITING
		超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。
		调用如下方法会使线程进入超时等待状态：
		Thread.sleep(long millis)：使当前线程睡眠指定时间；
		Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；
		Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；
		LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；LockSupport 我们在后面会细讲；
		LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；
	6) TERMINATED
		终止状态。此时线程已执行完毕
	***线程中断
			在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在 Java 里还没有安全方法来直接停止线程，但是 Java 提供了线程中断机制来处理需要中断线程的情况。
			线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。
			简单介绍下 Thread 类里提供的关于线程中断的几个方法：
			Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为 true（默认是 flase）；
			Thread.currentThread().isInterrupted()：测试当前线程是否被中断。线程的中断状态会受这个方法的影响，调用一次可以使线程中断状态变为 true，调用两次会使这个线程的中断状态重新转为 false；
			Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。
			在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为 true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己决定，可以在合适的时机中断请求，也可以完全不处理继续执行下去。
6. 通过线程组管理线程, 设置线程优先级
		Java 提供了 ThreadGroup 类来创建一组相关的线程，使线程组管理更方便。
		每个 Java 线程都有一个优先级，这个优先级会影响到操作系统为这个线程分配处理器时间的顺序。
		
1). 线程组(ThreadGroup)
		Java 用 ThreadGroup 来表示线程组，我们可以通过线程组对线程进行批量控制。

		ThreadGroup 和 Thread 的关系就如同他们的字面意思一样简单粗暴，每个 Thread 必然存在于一个 ThreadGroup 中，
		Thread 不能独立于 ThreadGroup 存在。执行main()方法的线程名字是 main，如果在 new Thread 时没有显式指定，
		那么默认将父线程（当前执行 new Thread 的线程）线程组设置为自己的线程组。
		ThreadGroup 是一个标准的向下引用的树状结构，这样设计可以防止"上级"线程被"下级"线程引用而无法有效地被 GC 回收。	
2). 线程组的常用方法及数据结构
		1) 获取当前线程的线程组的名字
			Thread.currentThread().getThreadGroup().getName()
		2) 复制线程组
			// 获取当前的线程组
			ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();
			// 复制一个线程组到一个线程数组（获取Thread信息）
			Thread[] threads = new Thread[threadGroup.activeCount()];
			threadGroup.enumerate(threads);
		3) 线程组统一异常处理
		4) 线程组的数据结构
			线程组还可以包含其他的线程组，不仅仅是线程。
			public class ThreadGroup implements Thread.UncaughtExceptionHandler {
					private final ThreadGroup parent; // 父亲ThreadGroup
					String name; // ThreadGroup 的名称
					int maxPriority; // 最大优先级
					boolean destroyed; // 是否被销毁
					boolean daemon; // 是否守护线程
					boolean vmAllowSuspension; // 是否可以中断

					int nUnstartedThreads = 0; // 还未启动的线程
					int nthreads; // ThreadGroup中线程数目
					Thread threads[]; // ThreadGroup中的线程

					int ngroups; // 线程组数目
					ThreadGroup groups[]; // 线程组数组
				}
3) 线程的优先级
			线程优先级可以指定，范围是 1~10。但并不是所有的操作系统都支持 10 级优先级的划分
			（比如有些操作系统只支持 3 级划分：低、中、高），Java 只是给操作系统一个优先级的参考值，线程最终在操作系统中的优先级还是由操作系统决定。
			Java 默认的线程优先级为 5，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。
			通常情况下，高优先级的线程将会比低优先级的线程有更高的概率得到执行。Thread类的setPriority()方法可以用来设定线程的优先级。
			
			Java 中的优先级不是特别的可靠，Java 程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。
			而真正的调用顺序，是由操作系统的线程调度算法来决定的。
			
			Java 提供了一个线程调度器来监视和控制处于RUNNABLE 状态的线程。
			线程的调度策略采用抢占式的方式，优先级高的线程会比优先级低的线程有更大的几率优先执行。
			在优先级相同的情况下，会按照“先到先得”的原则执行。
			每个 Java 程序都有一个默认的主线程，就是通过 JVM 启动的第一个线程——main 线程。
			还有一种特殊的线程，叫做守护线程（Daemon），守护线程默认的优先级比较低。

			如果某线程是守护线程，那如果所有的非守护线程都结束了，这个守护线程也会自动结束。
			当所有的非守护线程结束时，守护线程会自动关闭，这就免去了还要继续关闭子线程的麻烦。
			线程默认是非守护线程，可以通过 Thread 类的 setDaemon 方法来设置为守护线程。
			
4) 线程组和线程优先级之间的关系
			所以，如果某个线程的优先级大于线程所在线程组的最大优先级，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。
7. 进程和线程的区别
		进程和线程都是操作系统用于并发执行的方式，但是它们在资源管理、独立性、开销以及影响范围等方面有所不同。
		进程是操作系统分配资源的基本单位，线程是操作系统调度的基本单位。
		进程拥有独立的内存空间，线程共享所属进程的内存空间。
		进程的创建和销毁需要资源的分配和回收，开销较大；线程的创建和销毁只需要保存寄存器和栈信息，开销较小。
		进程间的通信比较复杂，而线程间的通信比较简单。
		进程间是相互独立的，一个进程崩溃不会影响其他进程；线程间是相互依赖的，一个线程崩溃可能影响整个程序的稳定性。
8. 并发编程或者说多线程带来了哪些问题
		1) 线程安全问题
			1. 原子性
				原子性：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
				原子操作：即不会被线程调度机制打断的操作，没有上下文切换。
			2. 可见性
				可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
				为了解决多线程的可见性问题，Java 提供了volatile这个关键字。当一个共享变量被 volatile 修饰时，
				它会保证修改的值立即更新到主存当中，这样的话，当有其他线程需要读取时，就会从内存中读到新值。
				普通的共享变量不能保证可见性，因为变量被修改后什么时候刷回到主存是不确定的，因此另外一个线程读到的可能就是旧值。
				当然 Java 的锁机制如 synchronized 和 lock 也是可以保证可见性的。
			3. 活跃性问题
				活跃性是指某件正确的事情最终会发生，但当某个操作无法继续下去的时候，就会发生活跃性问题。
				概念可能有点拗口，活跃性问题一般有这样几类：死锁，活锁，饥饿问题。
				
					死锁
				死锁是指多个线程因为环形等待锁的关系而永远地阻塞下去。
					活锁
				死锁是两个线程都在等待对方释放锁导致阻塞。而活锁的意思是线程没有阻塞，还活着呢。
				当多个线程都在运行并且都在修改各自的状态，而其他线程又依赖这个状态，就导致任何一个线程都无法继续执行，只能重复着自身的动作，于是就发生了活锁。
					饥饿
				如果一个线程无其他异常却迟迟不能继续运行，那基本上是处于饥饿状态了。
				高优先级的线程一直在运行消耗 CPU，所有的低优先级线程一直处于等待；
				一些线程被永久堵塞在一个等待进入同步块的状态，而其他线程总是能在它之前持续地对该同步块进行访问；
			4. 性能问题
			
				前面讲到了线程安全和死锁、活锁这些问题，如果这些都没有发生，多线程并发一定比单线程串行执行快吗？答案是不一定，因为多线程有创建线程和线程上下文切换的开销。
				创建线程是直接向系统申请资源的，对操作系统来说，创建一个线程的代价是十分昂贵的，需要给它分配内存、列入调度等。
				线程创建完之后，还会遇到线程上下文切换。
				CPU 是很宝贵的资源，速度非常快，为了保证雨露均沾，通常会给不同的线程分配时间片，当 CPU 从执行一个线程切换到执行另一个线程时，
				CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行线程的本地数据，程序指针等，也就是『上下文切换』。

				一般减少上下文切换的方法有：

				无锁并发编程：可以参照 ConcurrentHashMap 锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
				CAS 算法，利用 Atomic + CAS 算法来更新数据，采用乐观锁的方式，可以有效减少一部分不必要的锁竞争带来的上下文切换。
				使用最少线程：避免创建不必要的线程，如果任务很少，但创建了很多的线程，这样就会造成大量的线程都处于等待状态。
				协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。
9. JMM(Java内存模型)
		Java 内存模型 (JMM) 主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
		Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括以下几个部分：
		方法区、堆、栈、本地方法栈(native)、程序计数器
		并发编程的线程之间存在两个问题：
		线程间如何通信？即：线程之间以何种机制来交换信息
		线程间如何同步？即：线程以何种机制来控制不同线程间发生的相对顺序
		有两种并发模型可以解决这两个问题：
			1) 消息传递并发模型
			2) 共享内存并发模型
		1) 什么是共享变量
			对于每一个线程来说，栈都是私有的，而堆是共有的。
			也就是说，在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，
			也就不会有内存可见性的问题，也不受内存模型的影响。而在堆中的变量是共享的，一般称之为共享变量。
			所以，内存可见性针对的是堆中的共享变量。
		2) 内存可见性问题是如何发生的
			既然堆是共享的，为什么在堆中会有内存不可见问题
			这是因为现代计算机为了高效，往往会在高速缓存区中缓存共享变量，因为 CPU 访问缓存区比访问内存要快得多。
			线程之间的共享变量存在于主存中，每个线程都有一个私有的本地内存，存储了该线程的读、写共享变量的副本。
			本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。
			Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主存之间的抽象关系
			
				1. 所有的共享变量都存在主存中。
				2. 每个线程都保存了一份该线程使用到的共享变量的副本。
				3. 如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤：
				    1. 线程 A 将本地内存 A 中更新过的共享变量刷新到主存中去。
				    2. 线程 B 到主存中去读取线程 A 之前已经更新过的共享变量。
				所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主存。
				注意，根据 JMM 的规定，线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主存中读取。
				主内存：Java堆中对象实例数据部分，对应于物理硬件的内存
				工作内存：Java栈中的部分区域，优先存储于寄存器和高速缓存
				所以线程 B 并不是直接去主存中读取共享变量的值，而是先在本地内存 B 中找到这个共享变量，
				发现这个共享变量已经被更新了，然后本地内存 B 去主存中读取这个共享变量的新值，并拷贝到本地内存 B 中，最后线程 B 再读取本地内存 B 中的新值。
		3) 如何保证内存可见性?
			那么怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。JMM 通过控制主存与每个线程的本地内存之间的交互，来提供内存可见性保证。
			Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。
			在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员更方便地理解，设计者提出了 happens-before 的概念（下文会细讲），它更加简单易懂，
			从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则，以及这些规则的具体实现方法。
		4) JMM 与 Java 运行时内存区域的区别
			前面提到了 JMM 和 Java 运行时内存区域的划分，这两者既有差别又有联系：
					区别
				两者是不同的概念。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，
				围绕原子性、有序性、可见性等展开。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时必要的内存划分。
					联系
				都存在私有数据区域和共享数据区域。一般来说，JMM 中的主存属于共享数据区域，包含了堆和方法区；
				同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。
				总结一下：
				Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括以下几个部分：
				方法区：存储了每一个类的结构信息，如运行时常量池、字段和方法数据、构造方法和普通方法的字节码内容。
				堆：几乎所有的对象实例以及数组都在这里分配内存。这是 Java 内存管理的主要区域。
				栈：每一个线程有一个私有的栈，每一次方法调用都会创建一个新的栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息。所有的栈帧都是在方法调用和方法执行完成之后创建和销毁的。
				本地方法栈：与栈类似，不过本地方法栈为 JVM 使用到的 native 方法服务。
				程序计数器：每个线程都有一个独立的程序计数器，用于指示当前线程执行到了字节码的哪一行。
				Java 内存模型 (JMM) 主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
				它涵盖的主题包括变量的可见性、指令重排、原子操作等，旨在解决由于多线程并发编程带来的一些问题。
				可见性：当一个线程修改了共享变量的值，这个新值对于其他线程来说可以立即知道。
				原子性：一个或多个操作在整个过程中，不会被其他的线程或者操作所打断，这些操作是一个整体，要么都执行，要么都不执行。
				有序性：程序执行的顺序按照代码的先后顺序执行的。
		5) JMM与重排序
				重排序有哪几种？
			指令重排一般分为以下三种：
			1. 编译器优化重排，编译器在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
			2. 指令并行重排，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性
			(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。
			3. 内存系统重排，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去
			可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。
			指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。所以在多线程下，指令重排序可能会导致一些问题。
		6) JMM与顺序一致性模型
			当程序未正确同步的时候，就可能存在数据竞争。
			数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。
			如果程序中包含了数据竞争，那么运行的结果往往充满了不确定性，比如读发生在了写之前，可能就会读到错误的值；如果一个线程能够正确同步，那么就不存在数据竞争。
			Java 内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：如果程序是正确同步的，程序的执行将具有顺序一致性。即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。
			这里的同步包括使用 volatile、final、synchronized 等关键字实现的同步。
			如果我们开发者没有正确使用volatile、final、synchronized 等关键字，那么即便是使用了同步，JMM 也不会有内存可见性的保证，很可能会导致程序出错，并且不可重现，很难排查。
			
				什么是顺序一致性模型？
			顺序一致性模型是一个理想化的理论参考模型，它为程序提供了极强的内存可见性保证。顺序一致性模型有两大特性：
			一个线程中的所有操作必须按照程序的顺序（即 Java 代码的顺序）来执行。
			不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是原子性的，且立刻对所有线程可见。
			
				JMM 为什么不保证顺序一致性？
			顺序一致性模型中的每个操作必须立即对任意线程可见。
			但是 JMM 没有这样的保证。
			
			JMM 的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门。
			对于未同步的多线程，JMM 只提供最小安全性：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。
			为了实现这个安全性，JVM 在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。
			JMM 没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么 JMM 需要禁止大量的优化，对程序的执行性能会产生很大的影响。
			未同步程序在 JMM 和顺序一致性内存模型中的执行特性有如下差异：
			顺序一致性保证单线程内的操作会按程序的顺序执行；JMM 不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是 JMM 保证单线程下的重排序不影响执行结果）
			顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。（因为 JMM 不保证所有操作立即可见）
			顺序一致性模型保证对所有的内存读写操作都具有原子性，而 JMM 不保证对 64 位的 long 型和 double 型变量的写操作具有原子性。
			
		7) JMM与happens-before	
			一方面，我们开发者需要 JMM 提供一个强大的内存模型来编写代码；另一方面，编译器和处理器希望 JMM 对它们的束缚越少越好，这样它们就可以尽可能多的做优化来提高性能，希望的是一个弱的内存模型。
			JMM 考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。
			对于我们开发者来说，JMM 提供了happens-before 规则（JSR-133 规范），满足了我们的诉求——简单易懂，并且提供了足够强的内存可见性保证。 换言之，我们开发者只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。
			JMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程内，也可以是不同的线程种。
			happens-before 关系的定义如下：
			1. 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
			2. 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。
			如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。
			happens-before 关系本质上和 as-if-serial 语义是一回事。
			as-if-serial 语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before 关系保证正确同步的多线程程序的执行结果不被重排序改变。
			总之，如果操作 A happens-before 操作 B，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。
			#happens-before 关系有哪些？
			在 Java 中，有以下天然的 happens-before 关系：
			1. 程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。
			2. 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。
			3. volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
			4. 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
			5. start 规则：如果线程 A 执行操作 ThreadB.start()启动线程 B，那么 A 线程的 ThreadB.start()操作 happens-before 于线程 B 中的任意操作。
			6. join 规则：如果线程 A 执行操作 ThreadB.join()并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()操作成功返回。
		8) 重排序有两类，JMM 对这两类重排序有不同的策略：
			会改变程序执行结果的重排序，比如 A -> C，JMM 要求编译器和处理器都禁止这种重排序。
			不会改变程序执行结果的重排序，比如 A -> B，JMM 对编译器和处理器不做要求，允许这种重排序。
			#小结
			1. Java 内存模型（JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。
			2. Java 内存模型（JMM）主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。
			3. Java 运行时内存区域描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括方法区、堆、栈、本地方法栈、程序计数器。
			4. 指令重排是为了提高 CPU 性能，但是可能会导致一些问题，比如多线程环境下的内存可见性问题。
			5. happens-before 规则是 JMM 提供的强大的内存可见性保证，只要遵循 happens-before 规则，那么我们写的程序就能保证在 JMM 中具有强的内存可见性。
10. Java volatile关键字解析
	原子性: 读, 改, 写. read-modify-write(count++ 操作实际上包含了三个步骤)
		volatile 可以保证可见性，但不保证原子性：
	当写一个 volatile 变量时，JMM 会把该线程在本地内存中的变量强制刷新到主内存中去；
	这个写操作会导致其他线程中的 volatile 变量缓存无效。
	1. volatile会禁止重排序	
		当我们使用 volatile 关键字来修饰一个变量时，Java 内存模型会插入内存屏障（一个处理器指令，可以对 CPU 或编译器重排序做出约束）来确保以下两点：
		写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存。
		读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取。
		换句话说：
		当程序执行到 volatile 变量的读操作或者写操作时，在其前面操作的更改肯定已经全部进行，且结果对后面的操作可见；在其后面的操作肯定还没有进行；
		在进行指令优化时，不能将 volatile 变量的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。
	    也就是说，执行到 volatile 变量时，其前面的所有语句都必须执行完，后面所有得语句都未执行。且前面语句的结果对 volatile 变量及其后面语句可见。
	2. volatile不适用的场景
		1) 自增++
		01、采用 synchronized，把 inc++ 拎出来单独加 synchronized 关键字
		02、采用 Lock，通过重入锁 ReentrantLock 对 inc++ 加锁
		03、采用原子类 AtomicInteger
	3. volatile实现单例模式的双重锁
		"双重检查锁定"（double-checked locking）实现的单例模式（Singleton Pattern）
		使用 volatile 关键字是为了防止 m_penguin = new penguin() 这一步被指令重排序。实际上，new penguin() 这一步分为三个子步骤：
		1. 分配对象的内存空间。
		2. 初始化对象。
		3. 将 m_penguin 指向分配的内存空间。
	                     小结
		volatile 可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在 JVM 底层 volatile 是采用“内存屏障”来实现的。
		观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码就能发现，加入 volatile 关键字时，会多出一个 lock 前缀指令，
		lock 前缀指令实际上相当于一个内存屏障（也称内存栅栏），内存屏障会提供 3 个功能：
		1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
		2. 它会强制将对缓存的修改操作立即写入主存；
		3. 如果是写操作，它会导致其他 CPU 中对应的缓存行无效。
		最后，我们学习了 volatile 不适用的场景，以及解决的方法，并解释了双重检查锁定实现的单例模式为何需要使用 volatile。
11. synchronized关键字
	

	
###延生知识点#######################################################################################################################################################################
	1. 生产者-消费者模式
生产者-消费者模式（Producer-Consumer Pattern）是一种经典的并发编程模型，用于解决多个线程之间共享数据的同步问题。
这种模式通常用于描述两个或多个线程之间的协作关系，其中一个线程（生产者）负责生成数据并将其放入共享缓冲区，
而另一个线程（消费者）则从缓冲区中取出数据并进行处理。

在生产者-消费者模式中，生产者和消费者通常通过共享一个有限大小的缓冲区来交互。
生产者将生成的数据放入缓冲区，而消费者则从缓冲区中取出数据进行处理。
当缓冲区已满时，生产者会等待直到缓冲区中有空闲空间；当缓冲区为空时，消费者会等待直到缓冲区中有数据可供处理。

Java 中实现生产者-消费者模式有多种方式，以下是一种使用 java.util.concurrent 包中的 BlockingQueue 接口实现 
消息中间件都用到了这种设计模式: Java消息服务, Apache Kafka, RabbitMQ, Apache ActiveMQ
	ActiveMQ, RabbitMQ: 万级
	Kafka, RocketMQ: 十万级
	2. 线程按顺序执行的几种方法
 		1). join()
		2). t1 wait() t2 notify() 唤醒t1
		3). Countdownlatch latch.await(); // t2线程等待计数器减到零 
		3). Semaphore    
			acquire() release() 
		4).使用ExecutorService和Callable：ExecutorService是一个用于管理和控制线程池的框架。
			你可以使用ExecutorService的submit()方法提交Callable任务，并使用Future对象获取任务的结果。通过控制任务的提交顺序，你可以控制线程的执行顺序。
		5). CompletableFuture .supplyAsync thenRun
			runAsync    get()
			//等到所有任务都完成
			CompletableFuture.allOf(c1,c2,,,).get();
			gulimall/com/atguigu/gulimall/product/service/impl/SkuInfoServiceImpl.java
			
	3. 通过继承 Thread 的方法和实现 Runnable 接口的方式创建多线程，哪个好？
实现 Runable 接口好，原因有两个：

♠①、避免了 Java 单继承的局限性，Java 不支持多重继承，因此如果我们的类已经继承了另一个类，就不能再继承 Thread 类了。
♠②、适合多个相同的程序代码去处理同一资源的情况，把线程、代码和数据有效的分离，更符合面向对象的设计思想。Callable 接口与 Runnable 非常相似，但可以返回一个结果。

	4. volatile、synchronied、lock的区别: 
		volatile、synchronized是java关键字, volatile修饰变量, synchronized修饰方法或代码块
		lock是java的一个接口, 在java.util.concurrent.lock包中
		通常通过实现该接口的类 如: ReentrantLock来使用
****************************************************************************************************************


*****其他知识点#######################################################################################################################################################################

*******************************************
1. Java
	1).  标识符与关键字
		 标识符是用于给变量、类、方法、接口等命名的一种符号. 
		 要求:
		 1) 第一个字符不能是数字
		 2) 由数字、字母、下划线、美元符号组成
		 3) 标识符不能是关键字
		 4) 标识符不能是true、false、null
		 
		 java的50个关键字:
		 abstract 、assert 、boolean、break、byte、case、catch、char、class、const、continue、
		 default 、do、double、else、enum、extends、final、finally、float、for、goto、if、
		 implements、import、instanceof、int、interface、long、native、new、package、
		 private、protected、public、return、short 、static、strictfp、super、switch、synchronized、
		 this 、throw、throws、transient 、try 、void、volatile、while
		 1) abstract
		 在Java中，abstract是一个关键字，它用于声明抽象类或抽象方法。抽象类是一种不能被实例化的类，
		 它通常包含一些抽象方法，这些方法在抽象类中没有具体的实现。抽象类的主要目的是作为其他类的基类，
		 提供通用的属性和行为，同时允许子类根据需要实现特定的细节。
		 抽象方法只能声明在抽象类中.
		 2) assert
		 assert是一个关键字，用于进行断言。断言是一种调试工具，它允许程序员在代码中设置检查点，
		 以确保程序在运行时满足某些条件。如果条件为真（即断言成功），则程序将继续正常执行。
		 如果条件为假（即断言失败），则程序将抛出一个AssertionError异常。
		 在默认情况下，断言是禁用的。要启用断言，你需要在启动Java虚拟机（JVM）时通过命令行选项-enableassertions或-ea来启用它们
		 启用断言后，JVM会检查所有的assert语句。如果条件为假，它将抛出一个AssertionError异常，并显示你提供的错误消息（如果有的话）。
		 断言通常用于验证程序的状态或输入参数的有效性。它们不应该用于处理正常的程序逻辑，因为断言在默认情况下是禁用的，
		 并且在生产环境中通常不启用断言。断言主要用于开发和测试阶段，以帮助程序员发现和修复代码中的错误。
		 3) intanceof
		 判断对象是否符合指定的类型
		 instanceof关键字的作用是判断左边对象是否是右边类(这里有很多人说是对象，所以注意这里是类，并不是对象)的实例
		 (通俗易懂的说就是：子类对象，或者右边类本身的对象)返回的boolean类型，true和false。
		 if(o instanceof Yuan){//判断是否为圆的对象，不是则往下执行判断else if
				System.out.println("圆的面积为：" + ((Yuan)o).mianJi);//这里(Yuan)Object)防止参数o是Yuan的子类，此方法获得面积。
			System.out.println("圆的直径为：" + ((Yuan)o).zhiJing);//此方法获得直径。
			}else if（o instanceof ChangFangXing）{
				System.out.println("长方形的面积为：" + ((ChangFangXing)o));
			}
			4) native
			clone(), hashCode()
			它用于声明一个方法是原生的（native method）。一个原生方法是使用其他语言（如C、C++或汇编语言）编写的，
			并且被编译为机器代码，而不是Java字节码。然后，这个机器代码可以通过Java的本地接口（JNI，Java Native Interface）在Java程序中调用。
			 1)) 访问底层系统资源：Java是一种跨平台的语言，设计初衷是为了避免直接与底层硬件和操作系统进行交互。
			 然而，有时候为了性能考虑或者访问特定的系统资源，Java程序可能需要直接调用底层代码。

			2)) 性能优化：某些计算密集型任务可能使用原生代码（如C或C++）比使用Java代码执行得更快。

			3)) 利用现有的库：如果已经有现成的用其他语言编写的库或API，可以使用原生方法来调用这些库。

			4)) 遗留代码的集成：在集成遗留代码（legacy code）时，可能需要使用原生方法来调用这些已经用其他语言编写的代码。
			    // 声明一个原生方法  
			public native void myNativeMethod();  
  
				// 加载包含原生方法实现的库  
			static {  
				System.loadLibrary("NativeDemoLib");  
			}  
			原生方法的使用应该谨慎，因为它们破坏了Java的跨平台性，并且增加了代码的复杂性。在大多数情况下，应该优先考虑使用纯Java的解决方案。
			5) strictfp
			它用于声明一个方法或类，以确保在该方法或类中执行的浮点数运算遵循 IEEE 754 单精度或双精度浮点算术标准。IEEE 754 是定义浮点数表示和运算的标准。
			当你在一个方法或类上使用 strictfp 关键字时，该方法或类中的所有浮点运算（如加法、减法、乘法、除法和比较）都将按照 IEEE 754 标准进行。
			这确保了无论 Java 虚拟机（JVM）如何优化这些运算，结果都将是确定的，且与其他遵循相同标准的平台一致。
			strictfp 主要用于那些需要精确浮点运算的场景，例如金融计算，其中精确到小数点后几位是非常重要的。
			需要注意的是，strictfp 关键字并不能保证所有的浮点运算结果都是精确的，因为浮点数的表示本身就存在精度问题
			（例如，不是所有的十进制小数都能精确地用二进制浮点数表示）。然而，它确实确保了跨平台和跨 JVM 的浮点运算结果的一致性。
			6) throw和throws
			throw 用于在方法内部抛出异常对象。
			throws 用于在方法签名中声明方法可能抛出的异常类型。
			6) transient(暂时的)
			在实际开发过程中，我们常常会遇到这样的问题，一个类的有些字段需要序列化，有些字段不需要，
			比如说用户的一些敏感信息（如密码、银行卡号等），为了安全起见，不希望在网络操作中传输或者持久化到磁盘文件中，那这些字段就可以加上 transient 关键字。

			需要注意的是，被 transient 关键字修饰的成员变量在反序列化时会被自动初始化为默认值，例如基本数据类型为 0，引用类型为 null。
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
2). 基本数据类型转换
	int = short + short (JVM最小指令集运算为 int)
	为较小的类型引入专用的算术逻辑单元不值得付出努力：
	它需要额外的晶体管，但它仍然只能在一个时钟周期内执行一次加法。 JVM设计时的主流架构是32位，适合32位int。

----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
3). System.exit(status)不管status为何值都会退出程序。
	return是回到上一层，而System.exit(status)是回到最上层
	System.exit(0)是正常退出程序，而System.exit(1)或者说非0表示非正常退出程序
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
4). Java序列化
	1. 什么是Java序列化？
	Java序列化是指将Java对象转换为字节流的过程，以便可以将这些字节流保存到磁盘、发送到其他网络节点或用于其他目的。

	2. 为什么需要Java序列化？
	Java序列化主要用于对象的持久化，例如将对象保存到文件中或数据库中。
	它也用于在网络中传输对象，例如在远程方法调用（RMI）或分布式系统中。
	3. 如何实现Java序列化？
	要使一个类可序列化，必须实现java.io.Serializable接口。这是一个标记接口，没有定义任何方法。
	类的所有属性必须是可序列化的，如果属性不可序列化，则它们必须被标记为transient。
	4. transient关键字在Java序列化中起什么作用？
	transient关键字用于指示某个属性不应被序列化。它通常用于那些不能或不应被序列化的属性，例如线程、网络连接、文件句柄等。
	5. Java序列化有哪些版本控制机制？
	Java序列化提供了一种版本控制机制，通过serialVersionUID字段来实现。这是一个私有的、静态的、最终的long类型字段。
	当类的定义更改时，serialVersionUID也应该更改，以指示序列化和反序列化过程应验证类的版本兼容性。
	6. 什么是序列化ID (serialVersionUID)，它在Java序列化中起什么作用？
	serialVersionUID是一个唯一的版本号，用于标识类的不同版本。
	当类的定义发生更改时，serialVersionUID应该更改，以确保反序列化时对象与类的当前定义匹配。
	7. Java序列化和反序列化的过程是什么？
	序列化：将对象转换为字节流的过程。使用ObjectOutputStream类的writeObject()方法。
	反序列化：将字节流转换回对象的过程。使用ObjectInputStream类的readObject()方法。
	8. Java序列化有哪些限制？
	静态变量不会被序列化。
	瞬态变量（transient标记的变量）不会被序列化。
	序列化机制对于安全性有潜在的风险，因为它允许将任何对象转换为字节流，并可能在不受信任的环境中执行反序列化。
	9. 如何在Java中自定义序列化过程？
	通过实现writeObject()和readObject()方法来自定义序列化和反序列化过程。这些方法分别在ObjectOutputStream和ObjectInputStream中调用。
	10. Java序列化的安全性问题有哪些？
	反序列化恶意数据可能导致代码执行、拒绝服务攻击等。
	序列化数据可能包含敏感信息，如密码、密钥等。
	使用默认序列化机制可能导致数据泄露。
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
5). Java常见对象分类
	1. DAO（Data  Access Object）数据访问对象
				一般在业务逻辑层面对数据库的访问是使用，一般只能进行sql操作。
				xxxDAO，xxx为实体类名（entity实体类）。
	2. DTO（Data Transfer Object）数据传输对象
				一般在前端（web）对控制层（controller）进行数据传输时使用，说白了就是前端向后端提交数据。
				xxxDTO，xxx为业务领域相关的名称。
	3. DO（Domain Object）领域对象
			   一般在业务逻辑层对数据库的访问时使用接收数据使用。
			   xxxDO，xxx为数据库表名。
			   另外，DO和Entity概念上浅显相似，它们在实际应用中是一种东西，总的来说，DO是 Entity的一种。
	4.VO（View Object）视图模型
			   一般用在业务逻辑层，对前端的视觉模型效果控制的展示上，说白了就是后端向前端传递数据。
			   xxxVO，xxx为网页名称。
			  自定义的，再封装的，多个表的的属性或字段的集合。
	5. BO（Business Object）业务对象
				一般用在包含业务功能模块的具体实例上。
				比如我写了一个controller，一个service，一个dao，一个util，等等这一系列实例组合后才能实现一些功能，这些一系列实例组合为一个组件，这个组件就是BO。
	6. PO（Persistent Object）持久化对象
			   ·数据库表中的数据在Java对象中的显示状态，最理想的解释就是PO就是数据库中的一条记录。
			   ·例如我们有一条数据，现在有一个简单类而且是已经被赋予了这条数据的实例，那么这条数据在这个简单类的存在就是PO，不管这个是BO,DO，还是其它，PO只是数据持久化的              状态。
	7. Entity（应用程序中的一个概念）实体
				Entity是一个未被持久化的对象，它是一个类，从现实中抽象到代码的一个类。
	8. POJO（Plain Ordinary Java Object）
		普通的Java对象，其实就是简单的JavaBean实体类，对应数据库中的某一张表，POJO 中的每一个属性都应和表中字段一一对应。
6) String.intern()
	用于手动将字符串添加到字符串常量池中。如果常量池中已经包含了一个等于此 String 对象的字符串，则返回常量池中的这个字符串；否则，将此 String 对象添加到常量池中，并返回此 String 对象的引用。
7)  .equals() 和 ‘==’ 操作符有什么区别。”
	“==”操作符用于比较两个对象的地址是否相等。
	  .equals() 方法用于比较两个对象的内容是否相等。
8) 抽象类和接口
接口中的成员变量隐式为 static final，但抽象类不是的
		语法层面上
	抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；
	抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；
	接口中不能含有静态代码块，而抽象类可以有静态代码块；
	一个类只能继承一个抽象类，而一个类却可以实现多个接口。
		设计层面上
	抽象类对整体: 猫, 狗都是动物, 抽象成动物类
	接口对功能: 猫狗都会跑, 设计一个跑的接口
9) 封装, 继承, 多态
	封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。
	继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是复用代码。
	多态：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。
10)  重载和重写
		重载
	提高代码可读性：通过方法重载，我们可以为具有相同名称但参数类型或数量不同的方法提供不同的实现。这使得代码更加清晰易懂，因为开发者可以根据参数类型和数量直观地理解方法的功能。
	灵活性：方法重载允许我们在不改变方法名的情况下，通过改变参数类型和数量来实现不同的功能。这使得代码更加灵活，能够适应不同的使用场景。
	简化调用：在调用方法时，我们可以根据实际需要传递不同的参数类型和数量来调用不同的重载方法。这简化了方法的调用过程，提高了代码的可维护性。
			注意事项
		两同一不同:
			两同：在同一个类，方法名相同。
		一不同：参数不同。
		重写
	多态性：子类通过重写父类的方法，能够定义特定于自己的行为。这种多态性使得子类可以根据需要灵活地实现父类的方法，增强了代码的灵活性和可扩展性。
	完善父类功能：子类通过重写父类的方法，可以完善父类中的不足之处，使自身的方法更加完善。这有助于提升代码的质量和健壮性。
	代码复用：子类通过继承父类并重写其方法，可以复用父类的代码，减少重复编码的工作量。这有助于提高开发效率并降低维护成本。
			注意事项
		两同一小一大:
	两同：方法名相同，参数相同。”
	一小：子类方法声明的异常类型要比父类小一些或者相等。
	一大：子类方法的访问权限应该比父类的更大或者相等。
11) 注解
	注解（Annotation）是在 Java 1.5 时引入的概念，同 class 和 interface 一样，也属于一种类型。
	注解提供了一系列数据用来装饰程序代码（类、方法、字段等），但是注解并不是所装饰代码的一部分，它对代码的运行效果没有直接影响，由编译器决定该执行哪些操作。
12) 枚举
	枚举（enum），是 Java 1.5 时引入的关键字，它表示一种特殊类型的类，继承自 java.lang.Enum。
	枚举默认实现了 Serializable 接口

----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
3. 设计模式
	1. 创建型设计模式
		1) 工厂方法/
		2)
		3)
		4)
		5)
	2. 结构型设计模式
		
	3. 行为设计模式
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
4. Spring
1) 
----------------------------------------------------------------------------------------------------------------------------------		
----------------------------------------------------------------------------------------------------------------------------------	
3. 操作系统
	1) 进程，是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现了操作系统的并发。
	线程，是进程的子任务，是 CPU 调度和分派的基本单位，实现了进程内部的并发。
	2). CMD
		1) ping 主机, telnet 端口
		2) jmap -histo:live pid | head -n 10 命令就可以查看到堆内对象示例的统计信息、ClassLoader 的信息以及 finalizer 队列等。

	3. 7层架构

		物理层, 数据链路层, 
		网络层, 传输层,  会话层,  
		表示层, 应用层		
*******************************************
SAP

1. HI it::可以帮我看一下吗？这个工单我们的 IT 处理但是他们从新抛两次本来工单只做完8PCS而已，现在抛多一次所以抛多8PCS了！！你可以帮我取消一次吗？？
IT不能在正式環境作業，你用CO13 cancel掉一筆就行（如果你沒有CO13權限，找倉庫）。		 
		 
		 

		 
		 

